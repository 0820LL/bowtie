#ifndef EBWT_H_
#define EBWT_H_

#include <stdint.h>
#include <string.h>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <sstream>
#include <seqan/sequence.h>
#include <seqan/index.h>
#include "alphabet.h"
#include "assert_helpers.h"
#include "bitpack.h"
#include "blockwise_sa.h"
#include "endian_swap.h"
#include "word_io.h"
#include "random_source.h"
#include "hit.h"
#include "ref_read.h"
#include "threading.h"
#include "bitset.h"

using namespace std;
using namespace seqan;

#ifndef PREFETCH_LOCALITY
// No locality by default
#define PREFETCH_LOCALITY 0
#endif

// From ccnt_lut.cpp, automatically generated by gen_lookup_tables.pl
extern uint8_t cCntLUT_4[4][4][256];

#ifndef VMSG_NL
#define VMSG_NL(args...) \
if(this->verbose()) { \
	stringstream tmp; \
	tmp << args << endl; \
	this->verbose(tmp.str()); \
}
#endif

#ifndef VMSG
#define VMSG(args...) \
if(this->verbose()) { \
	stringstream tmp; \
	tmp << args; \
	this->verbose(tmp.str()); \
}
#endif

/**
 * Extended Burrows-Wheeler transform header.  This together with the
 * actual data arrays and other text-specific parameters defined in
 * class Ebwt constitute the entire Ebwt.
 */
class EbwtParams {

public:
	EbwtParams(uint32_t __len,
	           int32_t __lineRate,
	           int32_t __linesPerSide,
	           int32_t __offRate,
	           int32_t __ftabChars,
	           int32_t __chunkRate) :
	           _len(__len),        // # characters in the original string
	           _bwtLen(_len + 1),  // # characters in the BWT string ; extra 1 for $ suffix
	           _sz((_len+3)/4),    // # bytes needed to hold original string
	           _bwtSz(_len/4 + 1), // # bytes needed to hold BWT string
	           _lineRate(__lineRate),
	           _linesPerSide(__linesPerSide),
	           _origOffRate(__offRate),
	           _offRate(__offRate),
	           _offMask(0xffffffff << _offRate),
	           _ftabChars(__ftabChars),
	           _eftabLen(_ftabChars*2),
	           _eftabSz(_eftabLen*4),
	           _ftabLen((1 << (_ftabChars*2))+1),
	           _ftabSz(_ftabLen*4),
	           _offsLen((_bwtLen + (1 << _offRate) - 1) >> _offRate),
	           _offsSz(_offsLen*4),
	           _lineSz(1 << _lineRate),
	           _sideSz(_lineSz * _linesPerSide),
	           _sideBwtSz(_sideSz - 8),
	           _sideBwtLen(_sideBwtSz*4),
	           _numSidePairs((_bwtSz+(2*_sideBwtSz)-1)/(2*_sideBwtSz)), // string size rounded up to nearest line pair
	           _numSides(_numSidePairs*2),
	           _numLines(_numSides * _linesPerSide),
	           _ebwtTotLen(_numSidePairs * (2*_sideSz)),
	           _ebwtTotSz(_ebwtTotLen),
	           _chunkRate(__chunkRate),
	           _chunkLen(1 << _chunkRate),
	           _chunkMask(0xffffffff << _chunkRate),
	           _numChunks((_len + _chunkLen - 1) / _chunkLen)
	{
		assert(repOk());
	}

	EbwtParams(const EbwtParams& eh) :
	           _len(eh._len),
	           _bwtLen(eh._bwtLen),
	           _sz(eh._sz),
	           _bwtSz(eh._bwtSz),
	           _lineRate(eh._lineRate),
	           _linesPerSide(eh._linesPerSide),
	           _origOffRate(eh._origOffRate),
	           _offRate(eh._offRate),
	           _offMask(eh._offMask),
	           _ftabChars(eh._ftabChars),
	           _eftabLen(eh._eftabLen),
	           _eftabSz(eh._eftabSz),
	           _ftabLen(eh._ftabLen),
	           _ftabSz(eh._ftabSz),
	           _offsLen(eh._offsLen),
	           _offsSz(eh._offsSz),
	           _lineSz(eh._lineSz),
	           _sideSz(eh._sideSz),
	           _sideBwtSz(eh._sideBwtSz),
	           _sideBwtLen(eh._sideBwtLen),
	           _numSidePairs(eh._numSidePairs),
	           _numSides(eh._numSides),
	           _numLines(eh._numLines),
	           _ebwtTotLen(eh._ebwtTotLen),
	           _ebwtTotSz(eh._ebwtTotSz),
	           _chunkRate(eh._chunkRate),
	           _chunkLen(eh._chunkLen),
	           _chunkMask(eh._chunkMask),
	           _numChunks(eh._numChunks)
	{
		assert(repOk());
	}

	uint32_t len() const           { return _len; }
	uint32_t bwtLen() const        { return _bwtLen; }
	uint32_t sz() const            { return _sz; }
	uint32_t bwtSz() const         { return _bwtSz; }
	int32_t  lineRate() const      { return _lineRate; }
	int32_t  linesPerSide() const  { return _linesPerSide; }
	int32_t  origOffRate() const   { return _origOffRate; }
	int32_t  offRate() const       { return _offRate; }
	uint32_t offMask() const       { return _offMask; }
	int32_t  ftabChars() const     { return _ftabChars; }
	uint32_t eftabLen() const      { return _eftabLen; }
	uint32_t eftabSz() const       { return _eftabSz; }
	uint32_t ftabLen() const       { return _ftabLen; }
	uint32_t ftabSz() const        { return _ftabSz; }
	uint32_t offsLen() const       { return _offsLen; }
	uint32_t offsSz() const        { return _offsSz; }
	uint32_t lineSz() const        { return _lineSz; }
	uint32_t sideSz() const        { return _sideSz; }
	uint32_t sideBwtSz() const     { return _sideBwtSz; }
	uint32_t sideBwtLen() const    { return _sideBwtLen; }
	uint32_t numSidePairs() const  { return _numSidePairs; }
	uint32_t numSides() const      { return _numSides; }
	uint32_t numLines() const      { return _numLines; }
	uint32_t ebwtTotLen() const    { return _ebwtTotLen; }
	uint32_t ebwtTotSz() const     { return _ebwtTotSz; }
	int32_t  chunkRate() const     { return _chunkRate; }
	uint32_t chunkLen() const      { return _chunkLen; }
	uint32_t chunkMask() const     { return _chunkMask; }
	uint32_t numChunks() const     { return _numChunks; }

	/// Given a list of RefRecords and a few Ebwt parameters, calculate
	/// the chunkRate that minimizes total space taken by the index.
	static int32_t calcBestChunkRate(const vector<RefRecord>& szs,
	                                 int32_t offRate,
	                                 int32_t lineRate,
	                                 int32_t linesPerSide)
	{
		assert_geq(offRate, 0);
		assert_gt(lineRate, 0);
		assert_gt(linesPerSide, 0);
		uint32_t ps[12];
		memset(ps,  0, sizeof(uint32_t) * 12);
		uint32_t len = 0;
		for(size_t i = 0; i < szs.size(); i++) {
			const RefRecord& rec = szs[i];
			bool error = false;
			if(len + rec.off < len) {
				error = true; // overflowed
			} else {
				len += rec.off;
				if(len + rec.len < len) {
					error = true; // overflowed
				}
				else {
					len += rec.len;
				}
			}
			// If len overflowed, then bail
			if(error) {
				cerr << "The reference string is too long (>= 2^32 characters)." << endl;
				cerr << "Please shorten or subdivide the reference(s)." << endl;
				exit(1);
			}
			if(rec.len > 0) {
				// Calculate amount of padding needed for a range of
				// possible chunk rates
				for(size_t j = 0; j < 12; j++) {
					uint32_t masked = (rec.len & ~(0xffffffff << (j+6)));
					if(masked > 0) {
						// Factor in the padding due to this fragment.
						uint32_t pad = ((1 << (j+6)) - masked);
						if((ps[j] + pad) < ps[j]) {
							// We've saturated ps[j]!
							ps[j] = 0xffffffff;
						} else {
							ps[j] += pad;
						}
					}
				}
			}
		}
		// Calculate two penalties and add them together.  The first
		// penalty is the space incurred by the chunk descriptors,
		// which consist of 4 uint32_ts (16 bytes) per chunk.  The
		// second penalty is the space taken by the padding needed for
		// fragments.
		uint32_t bestj   = 0xffffffff;
		uint32_t bestpen = 0xffffffff;
		for(size_t j = 0; j < 12; j++) {
			if(ps[j] == 0xffffffff) {
				continue; // The padding already overflowed
			}
			uint32_t jlen = len + ps[j];
			if(jlen < len) {
				continue; // overflowed!
			}
			uint32_t pen = (ps[j] >> 2);             // BWT contribution (bytes)
			uint32_t offs = ((jlen >> offRate) * 4); // _offs contribution (bytes)
			if(pen + offs < pen) {
				continue; // overflowed!
			}
			pen += offs;
			uint32_t chunks = ((jlen >> (j+6)) * 16); // chunks contribution (bytes)
			if(pen + chunks < pen) {
				continue; // overflowed!
			}
			pen += chunks;
			// cumulative character occurrence counts contribution (2 uint32_ts per side)
			uint32_t occs = ((jlen / ((1 << lineRate)*linesPerSide)) * 8);
			if(pen + occs < pen) {
				continue; // overflowed!
			}
			pen += occs;
			if(pen < bestpen) {
				bestpen = pen;
				bestj = j;
			}
		}
		if(bestj == 0xffffffff) {
			// With padding, the
			cerr << "The joined and padded reference string is too long." << endl;
			cerr << "Please shorten or subdivide the reference(s)." << endl;
			exit(1);
		}
		assert_neq(0xffffffff, bestj);
		assert_neq(0xffffffff, bestpen);
		return bestj+6;
	}

	void setOffRate(int __offRate) {
		_offRate = __offRate;
        _offMask = 0xffffffff << _offRate;
        _offsLen = (_bwtLen + (1 << _offRate) - 1) >> _offRate;
        _offsSz = _offsLen*4;
	}

	/// Check that this EbwtParams is internally consistent
	bool repOk() const {
		assert_gt(_len, 0);
		assert_gt(_lineRate, 3);
		assert_geq(_offRate, 0);
		assert_leq(_ftabChars, 16);
		assert_geq(_ftabChars, 1);
		assert_geq(_chunkRate, 1);
		assert_lt(_chunkRate, 32);
		assert_lt(_lineRate, 32);
		assert_lt(_linesPerSide, 32);
		assert_lt(_ftabChars, 32);
		assert_eq(0, _ebwtTotSz % (2*_lineSz));
		return true;
	}

	/**
	 * Pretty-print the header contents to the given output stream.
	 */
	void print(ostream& out) const {
		out << "Headers:" << endl
		    << "    len: "          << _len << endl
		    << "    bwtLen: "       << _bwtLen << endl
		    << "    sz: "           << _sz << endl
		    << "    bwtSz: "        << _bwtSz << endl
		    << "    lineRate: "     << _lineRate << endl
		    << "    linesPerSide: " << _linesPerSide << endl
		    << "    offRate: "      << _offRate << endl
		    << "    offMask: 0x"    << hex << _offMask << dec << endl
		    << "    ftabChars: "    << _ftabChars << endl
		    << "    eftabLen: "     << _eftabLen << endl
		    << "    eftabSz: "      << _eftabSz << endl
		    << "    ftabLen: "      << _ftabLen << endl
		    << "    ftabSz: "       << _ftabSz << endl
		    << "    offsLen: "      << _offsLen << endl
		    << "    offsSz: "       << _offsSz << endl
		    << "    lineSz: "       << _lineSz << endl
		    << "    sideSz: "       << _sideSz << endl
		    << "    sideBwtSz: "    << _sideBwtSz << endl
		    << "    sideBwtLen: "   << _sideBwtLen << endl
		    << "    numSidePairs: " << _numSidePairs << endl
		    << "    numSides: "     << _numSides << endl
		    << "    numLines: "     << _numLines << endl
		    << "    ebwtTotLen: "   << _ebwtTotLen << endl
		    << "    ebwtTotSz: "    << _ebwtTotSz << endl
		    << "    chunkRate: "    << _chunkRate << endl
		    << "    chunkLen: "     << _chunkLen << endl
	        << "    chunkMask: "    << hex << _chunkMask << dec << endl
            << "    numChunks: "    << _numChunks << endl;
	}

//private:
    uint32_t _len;
    uint32_t _bwtLen;
    uint32_t _sz;
    uint32_t _bwtSz;
    int32_t  _lineRate;
    int32_t  _linesPerSide;
    int32_t  _origOffRate;
    int32_t  _offRate;
    uint32_t _offMask;
    int32_t  _ftabChars;
    uint32_t _eftabLen;
    uint32_t _eftabSz;
    uint32_t _ftabLen;
    uint32_t _ftabSz;
	uint32_t _offsLen;
	uint32_t _offsSz;
	uint32_t _lineSz;
	uint32_t _sideSz;
	uint32_t _sideBwtSz;
	uint32_t _sideBwtLen;
	uint32_t _numSidePairs;
	uint32_t _numSides;
	uint32_t _numLines;
	uint32_t _ebwtTotLen;
	uint32_t _ebwtTotSz;
	int32_t  _chunkRate;
	uint32_t _chunkLen;
	uint32_t _chunkMask;
	uint32_t _numChunks;
};

/**
 * Exception to throw when a file-realted error occurs.
 */
class EbwtFileOpenException : public std::runtime_error {
public:
	EbwtFileOpenException(const std::string& msg = "") :
		std::runtime_error(msg) { }
};

// Forward declarations for Ebwt class
class SideLocus;
template<typename TStr> class EbwtSearchParams;

/**
 * Extended Burrows-Wheeler transform data.
 *
 * An Ebwt may be transferred to and from RAM with calls to
 * evictFromMemory() and loadIntoMemory().  By default, a newly-created
 * Ebwt is not loaded into memory; if the user would like to use a
 * newly-created Ebwt to answer queries, they must first call
 * loadIntoMemory().
 */
template <typename TStr>
class Ebwt {
public:
	typedef typename Value<TStr>::Type TAlphabet;

	#define Ebwt_INITS \
	    _toBigEndian(currentlyBigEndian()), \
	    _overrideOffRate(__overrideOffRate), \
	    _verbose(__verbose), \
	    _sanity(__sanityCheck), \
	    _in1(), \
	    _in2(), \
	    _zOff(0xffffffff), \
	    _zEbwtByteOff(0xffffffff), \
	    _zEbwtBpOff(-1), \
	    _nPat(0), \
	    _plen(NULL), \
	    _pmap(NULL), \
	    _fchr(NULL), \
	    _ftab(NULL), \
	    _eftab(NULL), \
	    _offs(NULL), \
	    _ebwt(NULL), \
	    _refnames()

	/// Construct an Ebwt from the given input file
	Ebwt(const string& in,
	     int32_t __overrideOffRate = -1,
	     bool __verbose = false,
	     bool __sanityCheck = false) :
	     Ebwt_INITS,
	     _eh(readIntoMemory(true, in + ".1.ebwt", in + ".2.ebwt"))
	{
		// Read offs from secondary stream; if the offRate has been
		// overridden, make sure to sample the offs rather than take them
		// all
		if(_overrideOffRate > _eh._offRate) {
			_eh.setOffRate(_overrideOffRate);
			assert_eq(_overrideOffRate, _eh._offRate);
		}
		assert(repOk());
	}

	/// Construct an Ebwt from the given header parameters and string
	/// vector, optionally using a blockwise suffix sorter with the
	/// given 'bmax' and 'dcv' parameters.  The string vector is
	/// ultimately joined and the joined string is passed to buildToDisk().
	Ebwt(int32_t lineRate,
	     int32_t linesPerSide,
	     int32_t offRate,
	     int32_t ftabChars,
	     int32_t chunkRate,
	     const string& file,   // base filename for EBWT files
	     bool useBlockwise,
	     uint32_t bmax,
	     uint32_t bmaxSqrtMult,
	     uint32_t bmaxDivN,
	     int dcv,
	     vector<istream*>& is,
	     vector<RefRecord>& szs,
	     uint32_t sztot,
	     const RefReadInParams& refparams,
	     uint32_t seed,
	     int32_t __overrideOffRate = -1,
	     bool __verbose = false,
	     bool __sanityCheck = false) :
	     Ebwt_INITS,
	     _eh(joinedLen(szs, chunkRate), lineRate, linesPerSide, offRate, ftabChars, chunkRate)
	{
		string file1 = file + ".1.ebwt";
		string file2 = file + ".2.ebwt";
		// Open output files
		ofstream fout1(file1.c_str(), ios::binary);
		ofstream fout2(file2.c_str(), ios::binary);
		// Build
		initFromVector(is,
		               szs,
		               sztot,
		               refparams,
		               fout1,
		               fout2,
		               useBlockwise,
		               bmax,
		               bmaxSqrtMult,
		               bmaxDivN,
		               dcv,
		               seed);
		// Close output files
		fout1.flush();
		VMSG_NL("Wrote " << fout1.tellp() << " bytes to primary EBWT file: " << file1);
		fout1.close();
		fout2.flush();
		VMSG_NL("Wrote " << fout2.tellp() << " bytes to secondary EBWT file: " << file2);
		fout2.close();
		// Reopen as input streams
		VMSG_NL("Re-opening _in1 and _in2 as input streams");
		_in1.open(file1.c_str(), ios_base::in | ios::binary);
		_in2.open(file2.c_str(), ios_base::in | ios::binary);
		assert_eq((streamoff)_in1.tellg(), ios::beg);
		assert_eq((streamoff)_in2.tellg(), ios::beg);
		assert(_in1.good());
		assert(_in2.good());
		if(_sanity) {
			VMSG_NL("Sanity-checking Ebwt");
			assert(!isInMemory());
			readIntoMemory(false);
			sanityCheckAll();
			evictFromMemory();
			assert(!isInMemory());
			assert(_in1.is_open()); assert(_in1.good());
			assert(_in2.is_open()); assert(_in2.good());
			assert_eq((streamoff)_in1.tellg(), ios::beg);
			assert_eq((streamoff)_in2.tellg(), ios::beg);
		}
		VMSG_NL("Returning from Ebwt constructor");
	}

	/**
	 * Helper for the constructors above.  Takes a vector of text
	 * strings and joins them into a single string with a call to
	 * joinToDisk, which does a join (with padding) and writes some of
	 * the resulting data directly to disk rather than keep it in
	 * memory.  It then constructs a suffix-array producer (what kind
	 * depends on 'useBlockwise') for the resulting sequence.  The
	 * suffix-array producer can then be used to obtain chunks of the
	 * joined string's suffix array.
	 */
	void initFromVector(vector<istream*>& is,
	                    vector<RefRecord>& szs,
	                    uint32_t sztot,
	                    const RefReadInParams& refparams,
	                    ofstream& out1,
	                    ofstream& out2,
	                    bool useBlockwise,
	                    uint32_t bmax,
	                    uint32_t bmaxSqrtMult,
	                    uint32_t bmaxDivN,
	                    int dcv,
	                    uint32_t seed)
	{
		// Compose text strings into single string; doing so
		// initializes _plen, _pmap, _nPat
		VMSG_NL("Calculating joined length");
		TStr s; // holds the entire joined reference after call to joinToDisk
		uint32_t jlen = joinedLen(szs, _eh._chunkRate);
		assert_geq(jlen, sztot);
		VMSG_NL("  = " << jlen << " (" << (jlen-sztot) << " characters of padding)");
		VMSG_NL("Writing header");
		writeFromMemory(true, out1, out2);
		try {
			VMSG_NL("Reserving space for joined string");
			seqan::reserve(s, jlen, Exact());
			VMSG_NL("Joining reference sequences");
			{
				Timer timer(cout, "  Time to join reference sequences: ", _verbose);
				joinToDisk(is, szs, sztot, refparams, s, out1, out2, seed);
			}
		} catch(bad_alloc& e) {
			cerr << "Out of memory creating joined string in "
			     << "Ebwt::initFromVector() at " << __FILE__ << ":"
			     << __LINE__ << endl;
			exit(1);
		}
		assert_geq(length(s), jlen);
		if(useBlockwise) {
			if(bmax != 0xffffffff) {
				VMSG_NL("bmax according to bmax setting: " << bmax);
			}
			else if(bmaxSqrtMult != 0xffffffff) {
				bmax *= bmaxSqrtMult;
				VMSG_NL("bmax according to bmaxSqrtMult setting: " << bmax);
			}
			else if(bmaxDivN != 0xffffffff) {
				bmax = max<uint32_t>(jlen / bmaxDivN, 1);
				VMSG_NL("bmax according to bmaxDivN setting: " << bmax);
			}
			else {
				bmax = (uint32_t)sqrt(length(s));
				VMSG_NL("bmax defaulted to: " << bmax);
			}
			VMSG("Using blockwise SA w/ bmax=" << bmax);
			if(dcv == 0) {
				VMSG_NL(" and *no difference cover*");
			} else {
				VMSG_NL(", dcv=" << dcv);
			}
			KarkkainenBlockwiseSA<TStr> bsa(s, bmax, dcv, seed, _sanity, _verbose);
			assert(bsa.suffixItrIsReset());
			assert_eq(bsa.size(), length(s)+1);
			// Build Ebwt; doing so writes everything else (p
			buildToDisk(bsa, s, out1, out2);
		} else {
			VMSG_NL("Using entire SA");
			SillyBlockwiseDnaSA<TStr> bsa(s, 32, _sanity, _verbose);
			assert(bsa.suffixItrIsReset());
			assert_eq(bsa.size(), length(s)+1);
			// Build Ebwt; doing so initializes everything else
			buildToDisk(bsa, s, out1, out2);
		}
		assert(repOk());
		// Now write reference sequence names on the end
		assert_eq(this->_refnames.size(), this->_nPat);
		for(size_t i = 0; i < this->_refnames.size(); i++) {
			out1 << this->_refnames[i] << endl;
		}
		out1 << '\0';
		VMSG_NL("Returning from initFromVector");
	}

	/**
	 * Return the length that the joined string of the given string
	 * list will have.  Note that this is indifferent to how the text
	 * fragments correspond to input sequences - it just cares about
	 * the lengths of the fragments.
	 */
	uint32_t joinedLen(vector<RefRecord>& szs, uint32_t chunkRate) {
		uint32_t ret = 0;
		uint32_t chunkLen = 1 << chunkRate;
		for(unsigned int i = 0; i < szs.size(); i++) {
			ret += ((szs[i].len + chunkLen - 1) / chunkLen) * chunkLen;
		}
		return ret;
	}

	/// Destruct an Ebwt
	~Ebwt() {
		// Delete everything that was allocated in read(false, ...)
		if(_fchr  != NULL) delete[] _fchr;  _fchr  = NULL;
		if(_ftab  != NULL) delete[] _ftab;  _ftab  = NULL;
		if(_eftab != NULL) delete[] _eftab; _eftab = NULL;
		if(_offs  != NULL) delete[] _offs;  _offs  = NULL;
		if(_plen  != NULL) delete[] _plen;  _plen  = NULL;
		if(_pmap  != NULL) delete[] _pmap;  _pmap  = NULL;
		if(_ebwt  != NULL) delete[] _ebwt;  _ebwt  = NULL;
		try {
			if(_in1.is_open()) _in1.close();
			if(_in2.is_open()) _in2.close();
		} catch(...) {
			VMSG_NL("~Ebwt(): Caught an exception while closing streams!");
		}
	}

	/// Accessors
	const EbwtParams& eh() const     { return _eh; }
	uint32_t    zOff() const         { return _zOff; }
	uint32_t    zEbwtByteOff() const { return _zEbwtByteOff; }
	int         zEbwtBpOff() const   { return _zEbwtBpOff; }
	uint32_t    nPat() const         { return _nPat; }
	uint32_t*   fchr() const         { return _fchr; }
	uint32_t*   ftab() const         { return _ftab; }
	uint32_t*   eftab() const        { return _eftab; }
	uint32_t*   offs() const         { return _offs; }
	uint32_t*   plen() const         { return _plen; }
	uint32_t*   pmap() const         { return _pmap; }
	uint8_t*    ebwt() const         { return _ebwt; }
	bool        toBe() const         { return _toBigEndian; }
	bool        verbose() const      { return _verbose; }
	bool        sanityCheck() const  { return _sanity; }
	vector<string>& refnames()       { return _refnames; }

	/// Return true iff the Ebwt is currently in memory
	bool isInMemory() const {
		if(_ebwt != NULL) {
			assert(_eh.repOk());
			assert(_ftab != NULL);
			assert(_eftab != NULL);
			assert(_fchr != NULL);
			assert(_offs != NULL);
			assert(_pmap != NULL);
			assert_neq(_zEbwtByteOff, 0xffffffff);
			assert_neq(_zEbwtBpOff, -1);
			return true;
		} else {
			assert(_ftab == NULL);
			assert(_eftab == NULL);
			assert(_fchr == NULL);
			assert(_offs == NULL);
			assert(_pmap == NULL);
			assert_eq(_zEbwtByteOff, 0xffffffff);
			assert_eq(_zEbwtBpOff, -1);
			return false;
		}
	}

	/// Return true iff the Ebwt is currently stored on disk
	bool isEvicted() const {
		return !isInMemory();
	}

	/**
	 * Load this Ebwt into memory by reading it in from the _in1 and
	 * _in2 streams.
	 */
	void loadIntoMemory() {
		readIntoMemory(false);
	}

	/**
	 * Frees memory associated with the Ebwt.
	 */
	void evictFromMemory() {
		assert(isInMemory());
		delete[] _fchr;  _fchr  = NULL;
		delete[] _ftab;  _ftab  = NULL;
		delete[] _eftab; _eftab = NULL;
		delete[] _offs;  _offs  = NULL;
		// Keep plen; it's small and the client may want to query it
		// even when the others are evicted.
		//delete[] _plen;  _plen  = NULL;
		delete[] _pmap;  _pmap  = NULL;
		delete[] _ebwt;  _ebwt  = NULL;
		_zEbwtByteOff = 0xffffffff;
		_zEbwtBpOff = -1;
	}

	/**
	 * Non-static facade for static function ftabHi.
	 */
	uint32_t ftabHi(uint32_t i) const {
		return Ebwt::ftabHi(_ftab, _eftab, _eh._len, _eh._ftabLen, _eh._eftabLen, i);
	}

	/**
	 * Get "high interpretation" of ftab entry at index i.  The high
	 * interpretation of a regular ftab entry is just the entry
	 * itself.  The high interpretation of an extended entry is the
	 * second correpsonding ui32 in the eftab.
	 *
	 * It's a static member because it's convenient to ask this
	 * question before the Ebwt is fully initialized.
	 */
	static uint32_t ftabHi(uint32_t *ftab,
	                       uint32_t *eftab,
	                       uint32_t len,
	                       uint32_t ftabLen,
	                       uint32_t eftabLen,
	                       uint32_t i)
	{
		assert_lt(i, ftabLen);
		if(ftab[i] <= len) {
			return ftab[i];
		} else {
			uint32_t efIdx = ftab[i] ^ 0xffffffff;
			assert_lt(efIdx*2+1, eftabLen);
			return eftab[efIdx*2+1];
		}
	}

	/**
	 * Non-static facade for static function ftabLo.
	 */
	uint32_t ftabLo(uint32_t i) const {
		return Ebwt::ftabLo(_ftab, _eftab, _eh._len, _eh._ftabLen, _eh._eftabLen, i);
	}

	/**
	 * Get "low interpretation" of ftab entry at index i.  The low
	 * interpretation of a regular ftab entry is just the entry
	 * itself.  The low interpretation of an extended entry is the
	 * first correpsonding ui32 in the eftab.
	 *
	 * It's a static member because it's convenient to ask this
	 * question before the Ebwt is fully initialized.
	 */
	static uint32_t ftabLo(uint32_t *ftab,
	                       uint32_t *eftab,
	                       uint32_t len,
	                       uint32_t ftabLen,
	                       uint32_t eftabLen,
	                       uint32_t i)
	{
		assert_lt(i, ftabLen);
		if(ftab[i] <= len) {
			return ftab[i];
		} else {
			uint32_t efIdx = ftab[i] ^ 0xffffffff;
			assert_lt(efIdx*2+1, eftabLen);
			return eftab[efIdx*2];
		}
	}

	/**
	 * When using read() to create an Ebwt, we have to set a couple of
	 * additional fields in the Ebwt object that aren't part of the
	 * parameter list and are not stored explicitly in the file.  Right
	 * now, this just involves initializing _zEbwtByteOff and
	 * _zEbwtBpOff from _zOff.
	 */
	void postReadInit(EbwtParams& eh) {
		uint32_t sideNum     = _zOff / eh._sideBwtLen;
		uint32_t sideCharOff = _zOff % eh._sideBwtLen;
		uint32_t sideByteOff = sideNum * eh._sideSz;
		_zEbwtByteOff = sideCharOff >> 2;
		assert_lt(_zEbwtByteOff, eh._sideBwtSz);
		_zEbwtBpOff = sideCharOff & 3;
		assert_lt(_zEbwtBpOff, 4);
		if((sideNum & 1) == 0) {
			// This is an even (backward) side
			_zEbwtByteOff = eh._sideBwtSz - _zEbwtByteOff - 1;
			_zEbwtBpOff = 3 - _zEbwtBpOff;
			assert_lt(_zEbwtBpOff, 4);
		}
		_zEbwtByteOff += sideByteOff;
		assert(repOk(eh)); // Ebwt should be fully initialized now
	}

	/**
	 * Pretty-print the Ebwt to the given output stream.
	 */
	void print(ostream& out) const {
		print(out, _eh);
	}

	/**
	 * Pretty-print the Ebwt and given EbwtParams to the given output
	 * stream.
	 */
	void print(ostream& out, const EbwtParams& eh) const {
		eh.print(out); // print params
		out << "Ebwt (" << (isInMemory()? "memory" : "disk") << "):" << endl
		    << "    zOff: "         << _zOff << endl
		    << "    zEbwtByteOff: " << _zEbwtByteOff << endl
		    << "    zEbwtBpOff: "   << _zEbwtBpOff << endl
		    << "    nPat: "  << _nPat << endl
		    << "    plen: ";
		if(_plen == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _plen[0] << endl;
		}
		out << "    pmap: ";
		if(_pmap == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _pmap[0] << endl;
		}
		out << "    ebwt: ";
		if(_ebwt == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _ebwt[0] << endl;
		}
		out << "    fchr: ";
		if(_fchr == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _fchr[0] << endl;
		}
		out << "    ftab: ";
		if(_ftab == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _ftab[0] << endl;
		}
		out << "    eftab: ";
		if(_eftab == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _eftab[0] << endl;
		}
		out << "    offs: ";
		if(_offs == NULL) {
			out << "NULL" << endl;
		} else {
			out << "non-NULL, [0] = " << _offs[0] << endl;
		}
	}

	// Building
	static TStr join(vector<TStr>& l, uint32_t chunkRate, uint32_t seed);
	static TStr join(vector<istream*>& l, vector<RefRecord>& szs, uint32_t sztot, const RefReadInParams& refparams, uint32_t chunkRate, uint32_t seed);
	void joinToDisk(vector<istream*>& l, vector<RefRecord>& szs, uint32_t sztot, const RefReadInParams& refparams, TStr& ret, ostream& out1, ostream& out2, uint32_t seed);
	void buildToDisk(InorderBlockwiseSA<TStr>& sa, const TStr& s, ostream& out1, ostream& out2);

	// I/O
	EbwtParams readIntoMemory(bool justHeader, const string& in1, const string& in2);
	EbwtParams readIntoMemory(bool justHeader, const string& in1, const string& in2, bool& bigEndian);
	EbwtParams readIntoMemory(bool justHeader);
	EbwtParams readIntoMemory(bool justHeader, bool& be);
	void writeFromMemory(bool justHeader, ostream& out1, ostream& out2) const;
	void writeFromMemory(bool justHeader, const string& out1, const string& out2) const;

	// Sanity checking
	void printRangeFw(uint32_t begin, uint32_t end) const;
	void printRangeBw(uint32_t begin, uint32_t end) const;
	void sanityCheckUpToSide(int upToSide) const;
	void sanityCheckAll() const;
	void restore(TStr& s) const;
	void checkOrigs(const vector<String<Dna5> >& os, bool mirror) const;

	// Searching and reporting
	void joinedToTextOff(uint32_t qlen, uint32_t off, uint32_t& tidx, uint32_t& textoff, uint32_t& tlen, const EbwtSearchParams<TStr>& params) const;
	inline bool report(const String<Dna5>& query, String<char>* quals, String<char>* name, const uint32_t *mmui32, const char *refcs, size_t numMms, uint32_t off, uint32_t top, uint32_t bot, uint32_t qlen, int stratum, const EbwtSearchParams<TStr>& params) const;
	inline bool reportChaseOne(const String<Dna5>& query, String<char>* quals, String<char>* name, const uint32_t *mmui32, const char *refcs, size_t numMms, uint32_t i, uint32_t top, uint32_t bot, uint32_t qlen, int stratum, const EbwtSearchParams<TStr>& params, SideLocus *l = NULL) const;
	inline int rowL(const SideLocus& l) const;
	inline uint32_t countUpTo(const SideLocus& l, int c) const;
	inline void countUpToEx(const SideLocus& l, uint32_t* pairs) const;
	inline uint32_t countFwSide(const SideLocus& l, int c) const;
	inline void countFwSideEx(const SideLocus& l, uint32_t *pairs) const;
	inline uint32_t countBwSide(const SideLocus& l, int c) const;
	inline void countBwSideEx(const SideLocus& l, uint32_t *pairs) const;
	inline uint32_t mapLF(const SideLocus& l ASSERT_ONLY(, bool overrideSanity = false)) const;
	inline void mapLFEx(const SideLocus& l, uint32_t *pairs ASSERT_ONLY(, bool overrideSanity = false)) const;
	inline void mapLFEx(const SideLocus& ltop, const SideLocus& lbot, uint32_t *tops, uint32_t *bots ASSERT_ONLY(, bool overrideSanity = false)) const;
	inline uint32_t mapLF(const SideLocus& l, int c ASSERT_ONLY(, bool overrideSanity = false)) const;
	inline uint32_t mapLF1(const SideLocus& l, int c ASSERT_ONLY(, bool overrideSanity = false)) const;
	/// Check that in-memory Ebwt is internally consistent with respect
	/// to given EbwtParams; assert if not
	bool inMemoryRepOk(const EbwtParams& eh) const {
		assert_leq(ValueSize<TAlphabet>::VALUE, 4);
		assert_geq(_zEbwtBpOff, 0);
		assert_lt(_zEbwtBpOff, 4);
		assert_lt(_zEbwtByteOff, eh._ebwtTotSz);
		assert_lt(_zOff, eh._bwtLen);
		return true;
	}

	/// Check that in-memory Ebwt is internally consistent; assert if
	/// not
	bool inMemoryRepOk() const {
		return repOk(_eh);
	}

	/// Check that Ebwt is internally consistent with respect to given
	/// EbwtParams; assert if not
	bool repOk(const EbwtParams& eh) const {
		assert(_eh.repOk());
		if(isInMemory()) {
			return inMemoryRepOk(eh);
		}
		return true;
	}

	/// Check that Ebwt is internally consistent; assert if not
	bool repOk() const {
		return repOk(_eh);
	}

	bool       _toBigEndian;
	int32_t    _overrideOffRate;
	bool       _verbose;
	bool       _sanity;
	ifstream   _in1;
	ifstream   _in2;
	uint32_t   _zOff;
	uint32_t   _zEbwtByteOff;
	int        _zEbwtBpOff;
	uint32_t   _nPat;
	uint32_t*  _plen;
	// _plen ans e
	uint32_t*  _pmap;
	// _fchr, _ftab and _eftab are expected to be relatively small
	// (usually < 1MB, perhaps a few MB if _fchr is particularly large
	// - like, say, 11).  For this reason, we don't bother with writing
	// them to disk through separate output streams; we
	uint32_t*  _fchr;
	uint32_t*  _ftab;
	uint32_t*  _eftab; // "extended" entries for _ftab
	// _offs may be extremely large.  E.g. for DNA w/ offRate=4 (one
	// offset every 16 rows), the total size of _offs is the same as
	// the total size of the input sequence
	uint32_t*  _offs;
	// _ebwt is the Extended Burrows-Wheeler Transform itself, and thus
	// is at least as large as the input sequence.
	uint8_t*   _ebwt;
	vector<string> _refnames; /// names of the reference sequences
	EbwtParams _eh;

private:

	ostream& log() const {
		return cout; // TODO: turn this into a parameter
	}

	/// Print a verbose message and flush (flushing is helpful for
	/// debugging)
	void verbose(const string& s) const {
		if(this->verbose()) {
			this->log() << s;
			this->log().flush();
		}
	}
};

/**
 * Structure encapsulating search parameters, such as whether and how
 * to backtrack and how to deal with multiple equally-good hits.
 */
template<typename TStr>
class EbwtSearchParams {
public:
	EbwtSearchParams(HitSinkPerThread& __sink,
	                 const vector<String<Dna5> >& __texts,
	                 bool __revcomp = true,
	                 bool __fw = true,
	                 bool __ebwtFw = true,
	                 bool __arrowMode = false) :
		_sink(__sink),
		_texts(__texts),
		_patid(0xffffffff),
		_revcomp(__revcomp),
		_fw(__fw),
		_ebwtFw(__ebwtFw),
        _arrowMode(__arrowMode) { }
	HitSinkPerThread& sink() const   { return _sink; }
	void setPatId(uint32_t __patid)  { _patid = __patid; }
	uint32_t patId() const           { return _patid; }
	void setFw(bool __fw)            { _fw = __fw; }
	bool fw() const                  { return _fw; }
	void setEbwtFw(bool __ebwtFw)    { _ebwtFw = __ebwtFw; }
	bool ebwtFw() const              { return _ebwtFw; }
	/**
	 * Report a hit.  Returns true iff caller can call off the search.
	 */
	bool reportHit(const String<Dna5>& query, // read sequence
	               String<char>* quals, // read quality values
	               String<char>* name,  // read name
	               const uint32_t *mmui32, // mismatch list
	               const char *refcs,  // reference characters
	               size_t numMms,      // # mismatches
	               U32Pair h,          // hit position in reference
	               U32Pair a,          // arrow pair
	               uint32_t tlen,      // length of text
	               uint32_t len,       // length of query
	               int stratum,        // alignment stratum
	               uint32_t oms) const
	{
		// The search functions should not have allowed us to get here
		FixedBitset<max_read_bp> mm;
		String<Dna5> pat;
		uint32_t qlen = length(query);
		reserve(pat, qlen);
		String<char> patQuals;
		String<char> patName;
		vector<char> refc;
		// Make a copy of the read name
		if(name != NULL) assign(patName, *name);
		if (_ebwtFw) {
			// Let 'pat' and 'patQuals' become copies of 'query' and
			// '*quals'
			pat = query;
			if(quals != NULL) {
				reserve(patQuals, length(quals));
				patQuals = *quals;
			}
		} else {
			// Note: this is re-reversing the pattern and the quals
			// string back to their normal orientation; the pattern
			// source reversed it initially
			for(size_t i = 0; i < len; i++)
			{
				appendValue(pat, query[len-i-1]);
				if(quals != NULL && length(*quals) > 0) {
					appendValue(patQuals, (*quals)[len-i-1]);
				}
			}
		}
#ifndef NDEBUG
		// Check that no two elements of the mms array are the same
		for(size_t i = 0; i < numMms; i++) {
			for(size_t j = i+1; j < numMms; j++) {
				assert_neq(mmui32[i], mmui32[j]);
			}
		}
#endif
		// Turn the mmui32 and refcs arrays into the mm FixedBitset and
		// the refc vector
		refc.resize(qlen, 0);
		for(size_t i = 0; i < numMms; i++) {
			if (_ebwtFw != _fw) {
				// The 3' end is on the left but the mm vector encodes
				// mismatches w/r/t the 5' end, so we flip
				mm.set(len - mmui32[i] - 1);
				refc[len - mmui32[i] - 1] = refcs[i];
			}
			else {
				mm.set(mmui32[i]);
				refc[mmui32[i]] = refcs[i];
			}
		}
		// Check the hit against the original text, if it's available
		if(_texts.size() > 0 && !_arrowMode) {
			assert_lt(h.first, _texts.size());
			FixedBitset<max_read_bp> diffs;
			// This type of check assumes that only mismatches are
			// possible.  If indels are possible, then we either need
			// the caller to provide information about indel locations,
			// or we need to extend this to a more complicated check.
			assert_leq(h.second + len, length(_texts[h.first]));
			for(size_t i = 0; i < len; i++) {
				assert_neq(4, (int)_texts[h.first][h.second + i]);
				if(_ebwtFw) {
					// Forward pattern appears at h
					if((int)query[i] != (int)_texts[h.first][h.second + i]) {
						uint32_t qoff = i;
						// if _ebwtFw != _fw the 3' end is on on the
						// left end of the pattern, but the diff vector
						// should encode mismatches w/r/t the 5' end,
						// so we flip
						if (_ebwtFw != _fw) diffs.set(len - qoff - 1);
						else                diffs.set(qoff);
					}
				} else {
					// Reverse of pattern appears at h
					if((int)query[len-i-1] != (int)_texts[h.first][h.second + i]) {
						uint32_t qoff = len-i-1;
						// if _ebwtFw != _fw the 3' end is on on the
						// left end of the pattern, but the diff vector
						// should encode mismatches w/r/t the 5' end,
						// so we flip
						if (_ebwtFw != _fw) diffs.set(len - qoff - 1);
						else                diffs.set(qoff);
					}
				}
			}
			if(diffs != mm) {
				// Oops, mismatches were not where we expected them;
				// print a diagnostic message before asserting
				cerr << "Expected " << mm.str() << " mismatches, got " << diffs.str() << endl;
				cerr << "  Pat:  ";
				for(size_t i = 0; i < len; i++) {
					if(_ebwtFw) cerr << query[i];
					else cerr << query[len-i-1];
				}
				cerr << endl;
				cerr << "  Tseg: ";
				for(size_t i = 0; i < len; i++) {
					cerr << _texts[h.first][h.second + i];
				}
				cerr << endl;
				if(length(_texts[h.first]) < 80) {
					cerr << "  Text: " << _texts[h.first] << endl;
				}
				cerr << "  mmui32: ";
				for(size_t i = 0; i < numMms; i++) {
					cerr << mmui32[i] << " ";
				}
				cerr << endl;
				cerr << "  FW: " << _fw << endl;
				cerr << "  Ebwt FW: " << _ebwtFw << endl;
			}
			if(diffs != mm) assert(false);
		}
		// Report it using the HitSinkPerThread
		return sink().reportHit(
			Hit(_arrowMode? a : h,
			    _patid,
			    patName,
			    pat,
			    patQuals,
			    _fw,
			    mm,
			    refc,
			    oms), stratum);
	}
	bool arrowMode() const {
		return _arrowMode;
	}
	const vector<String<Dna5> >& texts() const { return _texts; }
private:
	HitSinkPerThread& _sink;
    const vector<String<Dna5> >& _texts; // original texts, if available (if not
                                // available, _texts.size() == 0)
	uint32_t _patid;      // id of current read
	bool _revcomp;        // whether reverse complements are enabled
	bool _fw;             // current read is forward-oriented
	bool _ebwtFw;         // current Ebwt is forward-oriented
	bool _arrowMode;      // report arrows
};

/**
 * Encapsulates a location in the bwt text in terms of the side it
 * occurs in and its offset within the side.
 */
struct SideLocus {
	SideLocus() :
	_sideByteOff(0),
	_sideNum(0),
	_charOff(0),
	_fw(-1),
	_by(-1),
	_bp(-1),
	_side(NULL) { }

	/**
	 * Construct from row and other relevant information about the Ebwt.
	 */
	SideLocus(uint32_t row, const EbwtParams& ep, uint8_t* ebwt) {
		initFromRow(row, ep, ebwt);
	}

	/**
	 * Init two SideLocus objects from a top/bot pair, using the result
	 * from one call to initFromRow to possibly avoid a second call.
	 */
	static void initFromTopBot(uint32_t top,
	                           uint32_t bot,
	                           const EbwtParams& ep,
	                           uint8_t* ebwt,
	                           SideLocus& ltop,
	                           SideLocus& lbot)
	{
		const uint32_t sideBwtLen = ep._sideBwtLen;
		const uint32_t sideBwtSz  = ep._sideBwtSz;
		assert_gt(bot, top);
		ltop.initFromRow(top, ep, ebwt);
		uint32_t spread = bot - top;
		if(ltop._charOff + spread < sideBwtLen) {
			lbot._charOff = ltop._charOff + spread;
			lbot._sideNum = ltop._sideNum;
			lbot._sideByteOff = ltop._sideByteOff;
			lbot._side = ltop._side;
			lbot._fw = ltop._fw;
			lbot._by = lbot._charOff >> 2;
			assert_lt(lbot._by, (int)sideBwtSz);
			if(!lbot._fw) lbot._by = sideBwtSz - lbot._by - 1;
			lbot._bp = lbot._charOff & 3;
			if(!lbot._fw) lbot._bp ^= 3;
		} else {
			lbot.initFromRow(bot, ep, ebwt);
		}
	}

	/**
	 * Calculate SideLocus based on a row and other relevant
	 * information about the shape of the Ebwt.
	 *
	 * Function gets 23.76% in profile
	 */
	void initFromRow(uint32_t row, const EbwtParams& ep, uint8_t* ebwt) {
		// Above line gets 2.02% in profile
		//const uint32_t sideBwtLen = ep._sideBwtLen;
		//const uint32_t sideBwtSz  = ep._sideBwtSz;
		const uint32_t sideSz     = ep._sideSz;
		_sideNum                  = row / 224;
		_charOff                  = row % 224;
		_sideByteOff              = _sideNum * sideSz;
		assert_leq(row, ep._len);
		assert_leq(_sideByteOff + sideSz, ep._ebwtTotSz);
		_side = ebwt + _sideByteOff;
#ifndef NO_PREFETCH
		// prefetch this side
		__builtin_prefetch((const void *)_side,
		                   0 /* prepare for read */,
		                   PREFETCH_LOCALITY /* no locality */); // 8.63% in profile
		// prefetch the other half of this side
		__builtin_prefetch((const void *)(_side + 64),
		                   0 /* prepare for read */,
		                   PREFETCH_LOCALITY /* no locality */);
#endif
		// prefetch tjside too
		_fw = _sideNum & 1;   // odd-numbered sides are forward
#ifndef NO_PREFETCH
		__builtin_prefetch((const void *)(_side + (_fw? -64 : 128)),
		                   0 /* prepare for read */,
		                   PREFETCH_LOCALITY /* no locality */); // 8.95% in profile
#endif
		_by = _charOff >> 2; // byte within side
		assert_lt(_by, (int)ep._sideBwtSz);
		_bp = _charOff & 3;  // bit-pair within byte
		if(!_fw) {
			_by = ep._sideBwtSz - _by - 1;
			_bp ^= 3;
		}
	}

    uint32_t _sideByteOff; // offset of top side within ebwt[]
    uint32_t _sideNum;     // index of side
    uint32_t _charOff;     // character offset within side
    int _fw;               // side is forward or backward?
    int _by;               // byte within side (not adjusted for bw sides)
    int _bp;               // bitpair within byte (not adjusted for bw sides)
    uint8_t *_side;        // ptr to beginning of top side
};

#include "ebwt_search_backtrack.h"

///////////////////////////////////////////////////////////////////////
//
// Functions for printing and sanity-checking Ebwts
//
///////////////////////////////////////////////////////////////////////

/**
 * Given a range of positions in the EBWT array within the BWT portion
 * of a forward side, print the characters at those positions along
 * with a summary occ[] array.
 */
template<typename TStr>
void Ebwt<TStr>::printRangeFw(uint32_t begin, uint32_t end) const {
	assert(isInMemory());
	uint32_t occ[] = {0, 0, 0, 0};
	assert_gt(end, begin);
	for(uint32_t i = begin; i < end; i++) {
		uint8_t by = this->_ebwt[i];
		for(int j = 0; j < 4; j++) {
			// Unpack from lowest to highest bit pair
			int twoBit = unpack_2b_from_8b(by, j);
			occ[twoBit]++;
			cout << "ACGT"[twoBit];
		}
		assert_eq(0, (occ[0] + occ[1] + occ[2] + occ[3]) & 3);
	}
	cout << ":{" << occ[0] << "," << occ[1] << "," << occ[2] << "," << occ[3] << "}" << endl;
}

/**
 * Given a range of positions in the EBWT array within the BWT portion
 * of a backward side, print the characters at those positions along
 * with a summary occ[] array.
 */
template<typename TStr>
void Ebwt<TStr>::printRangeBw(uint32_t begin, uint32_t end) const {
	assert(isInMemory());
	uint32_t occ[] = {0, 0, 0, 0};
	assert_gt(end, begin);
	for(uint32_t i = end-1; i >= begin; i--) {
		uint8_t by = this->_ebwt[i];
		for(int j = 3; j >= 0; j--) {
			// Unpack from lowest to highest bit pair
			int twoBit = unpack_2b_from_8b(by, j);
			occ[twoBit]++;
			cout << "ACGT"[twoBit];
		}
		assert_eq(0, (occ[0] + occ[1] + occ[2] + occ[3]) & 3);
		if(i == 0) break;
	}
	cout << ":{" << occ[0] << "," << occ[1] << "," << occ[2] << "," << occ[3] << "}" << endl;
}

/**
 * Check that the ebwt array is internally consistent up to (and not
 * including) the given side index by re-counting the chars and
 * comparing against the embedded occ[] arrays.
 */
template<typename TStr>
void Ebwt<TStr>::sanityCheckUpToSide(int upToSide) const {
	assert(isInMemory());
	uint32_t occ[] = {0, 0, 0, 0};
	uint32_t occ_save[] = {0, 0};
	uint32_t cur = 0; // byte pointer
	const EbwtParams& eh = this->_eh;
	bool fw = false;
	while(cur < (upToSide * eh._sideSz)) {
		assert_leq(cur + eh._sideSz, eh._ebwtTotLen);
		for(uint32_t i = 0; i < eh._sideBwtSz; i++) {
			uint8_t by = this->_ebwt[cur + (fw ? i : eh._sideBwtSz-i-1)];
			for(int j = 0; j < 4; j++) {
				// Unpack from lowest to highest bit pair
				int twoBit = unpack_2b_from_8b(by, fw ? j : 3-j);
				occ[twoBit]++;
				//if(_verbose) cout << "ACGT"[twoBit];
			}
			assert_eq(0, (occ[0] + occ[1] + occ[2] + occ[3]) % 4);
		}
		assert_eq(0, (occ[0] + occ[1] + occ[2] + occ[3]) % eh._sideBwtLen);
		if(fw) {
			// Finished forward bucket; check saved [G] and [T]
			// against the two uint32_ts encoded here
			ASSERT_ONLY(uint32_t *u32ebwt = reinterpret_cast<uint32_t*>(&this->_ebwt[cur + eh._sideBwtSz]));
			ASSERT_ONLY(uint32_t gs = u32ebwt[0]);
			ASSERT_ONLY(uint32_t ts = u32ebwt[1]);
			assert_eq(gs, occ_save[0]);
 			assert_eq(ts, occ_save[1]);
			fw = false;
		} else {
			// Finished backward bucket; check current [A] and [C]
			// against the two uint32_ts encoded here
			ASSERT_ONLY(uint32_t *u32ebwt = reinterpret_cast<uint32_t*>(&this->_ebwt[cur + eh._sideBwtSz]));
			ASSERT_ONLY(uint32_t as = u32ebwt[0]);
			ASSERT_ONLY(uint32_t cs = u32ebwt[1]);
			assert(as == occ[0] || as == occ[0]-1); // one 'a' is a skipped '$' and doesn't count toward occ[]
			assert_eq(cs, occ[1]);
 			occ_save[0] = occ[2]; // save gs
 			occ_save[1] = occ[3]; // save ts
			fw = true;
		}
		cur += eh._sideSz;
	}
}

/**
 * Sanity-check various pieces of the Ebwt
 */
template<typename TStr>
void Ebwt<TStr>::sanityCheckAll() const {
	const EbwtParams& eh = this->_eh;
	assert(isInMemory());
	// Check ftab
	for(uint32_t i = 1; i < eh._ftabLen; i++) {
		assert_geq(this->ftabHi(i), this->ftabLo(i-1));
		assert_geq(this->ftabLo(i), this->ftabHi(i-1));
		assert_leq(this->ftabHi(i), eh._bwtLen+1);
	}
	assert_eq(this->ftabHi(eh._ftabLen-1), eh._bwtLen);

	// Check offs
	int seenLen = (eh._bwtLen + 31) >> 5;
	uint32_t *seen;
	try {
		seen = new uint32_t[seenLen]; // bitvector marking seen offsets
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating seen[] at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}
	memset(seen, 0, 4 * seenLen);
	uint32_t offsLen = eh._offsLen;
	for(uint32_t i = 0; i < offsLen; i++) {
		assert_lt(this->_offs[i], eh._bwtLen);
		int w = this->_offs[i] >> 5;
		int r = this->_offs[i] & 31;
		assert_eq(0, (seen[w] >> r) & 1); // shouldn't have been seen before
		seen[w] |= (1 << r);
	}
	delete[] seen;

	// Check nPat
	assert_gt(this->_nPat, 0);

	// Check plen, flen
	for(uint32_t i = 0; i < this->_nPat; i++) {
		assert_geq(this->_plen[i], 0);
	}

	// Check pmap/plen
	for(uint32_t i = 0; i < eh._numChunks*4; i += 4) {
		// valid pattern id
		assert_lt(this->_pmap[i], this->_nPat);
		if(i > 0) {
			// pattern id in order
			assert_geq(this->_pmap[i], this->_pmap[i-4]);
		}
		// Fragment offset is less than fragment length
		assert_lt(this->_pmap[i+1], this->_plen[this->_pmap[i]]);
		// Fragment offset is less than fragment length
		assert_lt(this->_pmap[i+2], this->_pmap[i+3]);
		// Fragment length is less than or equal to sequence length
		assert_leq(this->_pmap[i+3], this->_plen[this->_pmap[i]]);
	}

	// Check ebwt
	sanityCheckUpToSide(eh._numSides);
	VMSG_NL("Ebwt::sanityCheck passed");
}

///////////////////////////////////////////////////////////////////////
//
// Functions for searching Ebwts
//
///////////////////////////////////////////////////////////////////////

/**
 * Return the final character in row i (i.e. the i'th character in the
 * BWT transform).  Note that the 'L' in the name of the function
 * stands for 'last', as in the literature.
 */
template<typename TStr>
inline int Ebwt<TStr>::rowL(const SideLocus& l) const {
	// Extract and return appropriate bit-pair
	return unpack_2b_from_8b(l._side[l._by], l._bp);
}

/**
 * Tricky-bit-bashing population count function for 64-bit argument.
 */
#define POP64(x) \
   x = x - ((x >> 1) & 0x5555555555555555llu); \
   x = (x & 0x3333333333333333llu) + ((x >> 2) & 0x3333333333333333llu); \
   x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0Fllu; \
   x = x + (x >> 8); \
   x = x + (x >> 16); \
   x = x + (x >> 32); \
   x = (x & 0x3F);

/**
 * Inline-function version of the above.  This does not always seem to
 * be inlined
 *
 * Function gets 3.38% in profile
 */
inline static int pop64(uint64_t x) {
   x = x - ((x >> 1) & 0x5555555555555555llu);
   x = (x & 0x3333333333333333llu) + ((x >> 2) & 0x3333333333333333llu);
   x = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0Fllu;
   x = x + (x >> 8);
   x = x + (x >> 16);
   x = x + (x >> 32);
   return x & 0x3F;
}

/**
 * Tricky-bit-bashing bitpair counting for given two-bit value (0-3)
 * within a 64-bit argument.
 *
 * Function gets 9.26% in profile
 */
inline static int countInU64(int c, uint64_t dw) {
	uint64_t dwA  = dw &  0xAAAAAAAAAAAAAAAAllu;
	uint64_t dwNA = dw & ~0xAAAAAAAAAAAAAAAAllu;
	uint64_t tmp;
	switch(c) {
	case 0:
		tmp = (dwA >> 1) | dwNA;
		break;
	case 1:
		tmp = ~(dwA >> 1) & dwNA;
		break;
	case 2:
		tmp = (dwA >> 1) & ~dwNA;
		break;
	case 3:
		tmp = (dwA >> 1) & dwNA;
		break;
	default:
		throw;
	}
	POP64(tmp); // Gets 7.62% in profile
	if(c == 0) {
		tmp = 32 - tmp;
	}
	assert_leq(tmp, 32);
	assert_geq(tmp, 0);
	return (int)tmp;
}

/**
 * Tricky-bit-bashing bitpair counting for given two-bit value (0-3)
 * within a 64-bit argument.
 *
 * Function gets 2.32% in profile
 */
inline static void countInU64Ex(uint64_t dw, uint32_t* arrs) {
	uint64_t dwA  = dw &  0xAAAAAAAAAAAAAAAAllu;
	uint64_t dwNA = dw & ~0xAAAAAAAAAAAAAAAAllu;
	arrs[0] += (32 - pop64((dwA >> 1) | dwNA));
	arrs[1] += pop64(~(dwA >> 1) & dwNA);
	arrs[2] += pop64((dwA >> 1) & ~dwNA);
	arrs[3] += pop64((dwA >> 1) & dwNA);
}

/**
 * Counts the number of occurrences of character 'c' in the given Ebwt
 * side up to (but not including) the given byte/bitpair (by/bp).
 *
 * This is a performance-critical function.  This is the top search-
 * related hit in the time profile.
 *
 * Function gets 11.09% in profile
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::countUpTo(const SideLocus& l, int c) const {
	uint32_t cCnt = 0;
	int i = 0;
	// Count occurrences of c in each 64-bit (using bit trickery);
	// note: this seems does not seem to lend a significant boost to
	// performance.  If you comment out this whole loop (which won't
	// affect correctness - it will just cause the following loop to
	// take up the slack) then runtime does not change noticeably.
	// Someday the countInU64() and pop() functions should be
	// vectorized/SSE-ized in case that helps.
	for(; i+7 < l._by; i += 8) { // 2.98% in profile
		cCnt += countInU64(c, *(uint64_t*)&l._side[i]); // 1.28% in profile
	}
	// Count occurences of c in the rest of the side (using LUT)
	for(; i < l._by; i++) {                  // 2.89% in profile
		cCnt += cCntLUT_4[0][c][l._side[i]]; // 2.37% in profile
	}
	// Count occurences of c in the rest of the byte
	if(l._bp > 0) {
		cCnt += cCntLUT_4[l._bp][c][l._side[i]]; // 1.15% in profile
	}
	return cCnt;
}

/**
 * Counts the number of occurrences of character 'c' in the given Ebwt
 * side up to (but not including) the given byte/bitpair (by/bp).
 *
 * Function gets 5.86% in the profile.
 */
template<typename TStr>
inline void Ebwt<TStr>::countUpToEx(const SideLocus& l, uint32_t* arrs) const {
	int i = 0;
	// Count occurrences of c in each 64-bit (using bit trickery);
	// note: this seems does not seem to lend a significant boost to
	// performance.  If you comment out this whole loop (which won't
	// affect correctness - it will just cause the following loop to
	// take up the slack) then runtime does not change noticeably.
	// Someday the countInU64() and pop() functions should be
	// vectorized/SSE-ized in case that helps.
	for(; i+7 < l._by; i += 8) {
		countInU64Ex(*(uint64_t*)&l._side[i], arrs);
	}
	// Count occurences of c in the rest of the side (using LUT)
	for(; i < l._by; i++) {
		arrs[0] += cCntLUT_4[0][0][l._side[i]]; // 0.73% + 0.63% + 0.63% + 0.63% in profile
		arrs[1] += cCntLUT_4[0][1][l._side[i]];
		arrs[2] += cCntLUT_4[0][2][l._side[i]];
		arrs[3] += cCntLUT_4[0][3][l._side[i]]; // 0.91% in profile
	}
	// Count occurences of c in the rest of the byte
	if(l._bp > 0) {
		arrs[0] += cCntLUT_4[l._bp][0][l._side[i]];
		arrs[1] += cCntLUT_4[l._bp][1][l._side[i]];
		arrs[2] += cCntLUT_4[l._bp][2][l._side[i]];
		arrs[3] += cCntLUT_4[l._bp][3][l._side[i]];
	}
}

/**
 * Count all occurrences of character c from the beginning of the
 * forward side to <by,bp> and add in the occ[] count up to the side
 * break just prior to the side.
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::countFwSide(const SideLocus& l, int c) const {
	const EbwtParams& eh = this->_eh;
	int by = l._by;
	int bp = l._bp;
	uint8_t *ebwtSide = l._side;
	uint32_t sideByteOff = l._sideByteOff;
	assert_lt(c, 4);
	assert_geq(c, 0);
	assert_lt(by, (int)eh._sideBwtSz);
	assert_geq(by, 0);
	assert_lt(bp, 4);
	assert_geq(bp, 0);
	uint32_t cCnt = countUpTo(l, c);
	assert_leq(cCnt, eh._sideBwtLen);
	if(c == 0 && sideByteOff <= _zEbwtByteOff && sideByteOff + by >= _zEbwtByteOff) {
		// Adjust for the fact that we represented $ with an 'A', but
		// shouldn't count it as an 'A' here
		if(sideByteOff + by > _zEbwtByteOff ||
		   sideByteOff + by == _zEbwtByteOff && bp > _zEbwtBpOff)
		{
			cCnt--; // Adjust for '$' looking like an 'A'
		}
	}
	uint32_t ret;
	// Now factor in the occ[] count at the side break
	if(c < 2) {
		uint32_t *ac = reinterpret_cast<uint32_t*>(ebwtSide - 8);
		assert_leq(ac[0], eh._numSides * eh._sideBwtLen); // b/c it's used as padding
		assert_lt(ac[1], eh._len);
		ret = ac[c] + cCnt + this->_fchr[c];
	} else {
		uint32_t *gt = reinterpret_cast<uint32_t*>(ebwtSide + eh._sideSz - 8); // next
		assert_lt(gt[0], eh._len); assert_lt(gt[1], eh._len);
		ret = gt[c-2] + cCnt + this->_fchr[c];
	}
#ifndef NDEBUG
	assert_leq(ret, this->_fchr[c+1]); // can't have jumpded into next char's section
	if(c == 0) {
		assert_leq(cCnt, eh._sideBwtLen);
	} else {
		assert_lt(ret, eh._bwtLen);
	}
#endif
	return ret;
}

/**
 * Count all occurrences of character c from the beginning of the
 * forward side to <by,bp> and add in the occ[] count up to the side
 * break just prior to the side.
 */
template<typename TStr>
inline void Ebwt<TStr>::countFwSideEx(const SideLocus& l, uint32_t* arrs) const
{
	const EbwtParams& eh = this->_eh;
	int by = l._by;
	int bp = l._bp;
	uint8_t *ebwtSide = l._side;
	uint32_t sideByteOff = l._sideByteOff;
	assert_lt(by, (int)eh._sideBwtSz);
	assert_geq(by, 0);
	assert_lt(bp, 4);
	assert_geq(bp, 0);
	countUpToEx(l, arrs);
	assert_leq(arrs[0], eh._sideBwtLen);
	assert_leq(arrs[1], eh._sideBwtLen);
	assert_leq(arrs[2], eh._sideBwtLen);
	assert_leq(arrs[3], eh._sideBwtLen);
	if(sideByteOff <= _zEbwtByteOff && sideByteOff + by >= _zEbwtByteOff) {
		// Adjust for the fact that we represented $ with an 'A', but
		// shouldn't count it as an 'A' here
		if(sideByteOff + by > _zEbwtByteOff ||
		   sideByteOff + by == _zEbwtByteOff && bp > _zEbwtBpOff)
		{
			arrs[0]--; // Adjust for '$' looking like an 'A'
		}
	}
	// Now factor in the occ[] count at the side break
	uint32_t *ac = reinterpret_cast<uint32_t*>(ebwtSide - 8);
	uint32_t *gt = reinterpret_cast<uint32_t*>(ebwtSide + eh._sideSz - 8);
#ifndef NDEBUG
	assert_leq(ac[0], this->_fchr[1] + eh.sideBwtLen());
	assert_leq(ac[1], this->_fchr[2]-this->_fchr[1]);
	assert_leq(gt[0], this->_fchr[3]-this->_fchr[2]);
	assert_leq(gt[1], this->_fchr[4]-this->_fchr[3]);
#endif
	assert_lt(ac[0], eh._len + eh.sideBwtLen()); assert_lt(ac[1], eh._len);
	assert_lt(gt[0], eh._len); assert_lt(gt[1], eh._len);
	arrs[0] += (ac[0] + this->_fchr[0]);
	arrs[1] += (ac[1] + this->_fchr[1]);
	arrs[2] += (gt[0] + this->_fchr[2]);
	arrs[3] += (gt[1] + this->_fchr[3]);
#ifndef NDEBUG
	assert_leq(arrs[0], this->_fchr[1]); // can't have jumpded into next char's section
	assert_leq(arrs[1], this->_fchr[2]); // can't have jumpded into next char's section
	assert_leq(arrs[2], this->_fchr[3]); // can't have jumpded into next char's section
	assert_leq(arrs[3], this->_fchr[4]); // can't have jumpded into next char's section
#endif
}

/**
 * Count all instances of character c from <by,bp> to the logical end
 * (actual beginning) of the backward side, and subtract that from the
 * occ[] count up to the side break.
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::countBwSide(const SideLocus& l, int c) const {
	const EbwtParams& eh = this->_eh;
	int by = l._by;
	int bp = l._bp;
	uint8_t *ebwtSide = l._side;
	uint32_t sideByteOff = l._sideByteOff;
	assert_lt(c, 4);
	assert_geq(c, 0);
	assert_lt(by, (int)eh._sideBwtSz);
	assert_geq(by, 0);
	assert_lt(bp, 4);
	assert_geq(bp, 0);
	uint32_t cCnt = countUpTo(l, c);
	if(unpack_2b_from_8b(ebwtSide[by], bp) == c) cCnt++;
	assert_leq(cCnt, eh._sideBwtLen);
	if(c == 0 && sideByteOff <= _zEbwtByteOff && sideByteOff + by >= _zEbwtByteOff) {
		// Adjust for the fact that we represented $ with an 'A', but
		// shouldn't count it as an 'A' here
		if(sideByteOff + by > _zEbwtByteOff ||
		   sideByteOff + by == _zEbwtByteOff && bp >= _zEbwtBpOff)
		{
			cCnt--;
		}
	}
	uint32_t ret;
	// Now factor in the occ[] count at the side break
	if(c < 2) {
		uint32_t *ac = reinterpret_cast<uint32_t*>(ebwtSide + eh._sideSz - 8);
		assert_leq(ac[0], eh._numSides * eh._sideBwtLen); // b/c it's used as padding
		assert_lt(ac[1], eh._len);
		ret = ac[c] - cCnt + this->_fchr[c];
	} else {
		uint32_t *gt = reinterpret_cast<uint32_t*>(ebwtSide + (2*eh._sideSz) - 8); // next
		assert_lt(gt[0], eh._len); assert_lt(gt[1], eh._len);
		ret = gt[c-2] - cCnt + this->_fchr[c];
	}
#ifndef NDEBUG
	assert_leq(ret, this->_fchr[c+1]); // can't have jumped into next char's section
	if(c == 0) {
		assert_leq(cCnt, eh._sideBwtLen);
	} else {
		assert_lt(ret, eh._bwtLen);
	}
#endif
	return ret;
}

/**
 * Count all instances of character c from <by,bp> to the logical end
 * (actual beginning) of the backward side, and subtract that from the
 * occ[] count up to the side break.
 */
template<typename TStr>
inline void Ebwt<TStr>::countBwSideEx(const SideLocus& l, uint32_t* arrs) const {
	const EbwtParams& eh = this->_eh;
	int by = l._by;
	int bp = l._bp;
	uint8_t *ebwtSide = l._side;
	uint32_t sideByteOff = l._sideByteOff;
	assert_lt(by, (int)eh._sideBwtSz);
	assert_geq(by, 0);
	assert_lt(bp, 4);
	assert_geq(bp, 0);
	countUpToEx(l, arrs);
	arrs[unpack_2b_from_8b(ebwtSide[by], bp)]++;
	assert_leq(arrs[0], eh._sideBwtLen);
	assert_leq(arrs[1], eh._sideBwtLen);
	assert_leq(arrs[2], eh._sideBwtLen);
	assert_leq(arrs[3], eh._sideBwtLen);
	if(sideByteOff <= _zEbwtByteOff && sideByteOff + by >= _zEbwtByteOff) {
		// Adjust for the fact that we represented $ with an 'A', but
		// shouldn't count it as an 'A' here
		if(sideByteOff + by > _zEbwtByteOff ||
		   sideByteOff + by == _zEbwtByteOff && bp >= _zEbwtBpOff)
		{
			arrs[0]--; // Adjust for '$' looking like an 'A'
		}
	}
	// Now factor in the occ[] count at the side break
	uint32_t *ac = reinterpret_cast<uint32_t*>(ebwtSide + eh._sideSz - 8);
	uint32_t *gt = reinterpret_cast<uint32_t*>(ebwtSide + (2*eh._sideSz) - 8);
#ifndef NDEBUG
	assert_leq(ac[0], this->_fchr[1] + eh.sideBwtLen());
	assert_leq(ac[1], this->_fchr[2]-this->_fchr[1]);
	assert_leq(gt[0], this->_fchr[3]-this->_fchr[2]);
	assert_leq(gt[1], this->_fchr[4]-this->_fchr[3]);
#endif
	assert_lt(ac[0], eh._len + eh.sideBwtLen()); assert_lt(ac[1], eh._len);
	assert_lt(gt[0], eh._len); assert_lt(gt[1], eh._len);
	arrs[0] = (ac[0] - arrs[0] + this->_fchr[0]);
	arrs[1] = (ac[1] - arrs[1] + this->_fchr[1]);
	arrs[2] = (gt[0] - arrs[2] + this->_fchr[2]);
	arrs[3] = (gt[1] - arrs[3] + this->_fchr[3]);
#ifndef NDEBUG
	assert_leq(arrs[0], this->_fchr[1]); // can't have jumpded into next char's section
	assert_leq(arrs[1], this->_fchr[2]); // can't have jumpded into next char's section
	assert_leq(arrs[2], this->_fchr[3]); // can't have jumpded into next char's section
	assert_leq(arrs[3], this->_fchr[4]); // can't have jumpded into next char's section
#endif
}

/**
 * Given top and bot loci, calculate counts of all four DNA chars up to
 * those loci.  Used for more advanced backtracking-search.
 */
template<typename TStr>
inline void Ebwt<TStr>::mapLFEx(const SideLocus& ltop,
                                const SideLocus& lbot,
                                uint32_t *tops,
                                uint32_t *bots
                                ASSERT_ONLY(, bool overrideSanity)
                                ) const
{
	// TODO: Where there's overlap, reuse the count for the overlapping
	// portion
	assert_eq(0, tops[0]); assert_eq(0, bots[0]);
	assert_eq(0, tops[1]); assert_eq(0, bots[1]);
	assert_eq(0, tops[2]); assert_eq(0, bots[2]);
	assert_eq(0, tops[3]); assert_eq(0, bots[3]);
	if(ltop._fw) countFwSideEx(ltop, tops); // Forward side
	else         countBwSideEx(ltop, tops); // Backward side
	if(lbot._fw) countFwSideEx(lbot, bots); // Forward side
	else         countBwSideEx(lbot, bots); // Backward side
#ifndef NDEBUG
	if(_sanity && !overrideSanity) {
		// Make sure results match up with individual calls to mapLF;
		// be sure to override sanity-checking in the callee, or we'll
		// have infinite recursion
		assert_eq(mapLF(ltop, 0, true), tops[0]);
		assert_eq(mapLF(ltop, 1, true), tops[1]);
		assert_eq(mapLF(ltop, 2, true), tops[2]);
		assert_eq(mapLF(ltop, 3, true), tops[3]);
		assert_eq(mapLF(lbot, 0, true), bots[0]);
		assert_eq(mapLF(lbot, 1, true), bots[1]);
		assert_eq(mapLF(lbot, 2, true), bots[2]);
		assert_eq(mapLF(lbot, 3, true), bots[3]);
	}
#endif
}

/**
 * Given top and bot loci, calculate counts of all four DNA chars up to
 * those loci.  Used for more advanced backtracking-search.
 */
template<typename TStr>
inline void Ebwt<TStr>::mapLFEx(const SideLocus& l,
                                uint32_t *arrs
                                ASSERT_ONLY(, bool overrideSanity)
                                ) const
{
	assert_eq(0, arrs[0]);
	assert_eq(0, arrs[1]);
	assert_eq(0, arrs[2]);
	assert_eq(0, arrs[3]);
	if(l._fw) countFwSideEx(l, arrs); // Forward side
	else      countBwSideEx(l, arrs); // Backward side
#ifndef NDEBUG
	if(_sanity && !overrideSanity) {
		// Make sure results match up with individual calls to mapLF;
		// be sure to override sanity-checking in the callee, or we'll
		// have infinite recursion
		assert_eq(mapLF(l, 0, true), arrs[0]);
		assert_eq(mapLF(l, 1, true), arrs[1]);
		assert_eq(mapLF(l, 2, true), arrs[2]);
		assert_eq(mapLF(l, 3, true), arrs[3]);
	}
#endif
}

/**
 * Given row i, return the row that the LF mapping maps i to.
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::mapLF(const SideLocus& l
                                  ASSERT_ONLY(, bool overrideSanity)
                                  ) const
{
	uint32_t ret;
	int c = unpack_2b_from_8b(l._side[l._by], l._bp);
	assert_lt(c, 4);
	assert_geq(c, 0);
	if(l._fw) ret = countFwSide(l, c); // Forward side
	else      ret = countBwSide(l, c); // Backward side
	assert_lt(ret, this->_eh._bwtLen);
#ifndef NDEBUG
	if(_sanity && !overrideSanity) {
		// Make sure results match up with results from mapLFEx;
		// be sure to override sanity-checking in the callee, or we'll
		// have infinite recursion
		uint32_t arrs[] = { 0, 0, 0, 0 };
		mapLFEx(l, arrs, true);
		assert_eq(arrs[c], ret);
	}
#endif
	return ret;
}

/**
 * Given row i and character c, return the row that the LF mapping maps
 * i to on character c.
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::mapLF(const SideLocus& l, int c
                                  ASSERT_ONLY(, bool overrideSanity)
                                  ) const
{
	uint32_t ret;
	assert_lt(c, 4);
	assert_geq(c, 0);
	if(l._fw) ret = countFwSide(l, c); // Forward side
	else      ret = countBwSide(l, c); // Backward side
	assert_lt(ret, this->_eh._bwtLen);
#ifndef NDEBUG
	if(_sanity && !overrideSanity) {
		// Make sure results match up with results from mapLFEx;
		// be sure to override sanity-checking in the callee, or we'll
		// have infinite recursion
		uint32_t arrs[] = { 0, 0, 0, 0 };
		mapLFEx(l, arrs, true);
		assert_eq(arrs[c], ret);
	}
#endif
	return ret;
}

/**
 * Like mapLF1, except it returns 0xffffffff if the character int the
 * final column of row i is not c.  This is an optimization for the
 * (hopefully common) case where we're matching and the top and bottom
 * arrows are separated by a single row.
 *
 * Is it because this is the first place to read from the side, thus
 * taking the cache miss?
 */
template<typename TStr>
inline uint32_t Ebwt<TStr>::mapLF1(const SideLocus& l, int c
                                   ASSERT_ONLY(, bool overrideSanity)) const
{
	uint32_t ret;
	if(c == 4 || unpack_2b_from_8b(l._side[l._by], l._bp) != c) { // L2 miss?
		return 0xffffffff;
	}
	assert_lt(c, 4);
	assert_geq(c, 0);
	if(l._fw) ret = countFwSide(l, c); // Forward side
	else      ret = countBwSide(l, c); // Backward side
	assert_lt(ret, this->_eh._bwtLen);
#ifndef NDEBUG
	if(_sanity && !overrideSanity) {
		// Make sure results match up with results from mapLFEx;
		// be sure to override sanity-checking in the callee, or we'll
		// have infinite recursion
		uint32_t arrs[] = { 0, 0, 0, 0 };
		mapLFEx(l, arrs, true);
		assert_eq(arrs[c], ret);
	}
#endif
	return ret;
}

#if 1
/**
 * Take an offset into the joined text and translate it into the
 * reference of the index it falls on, the offset into the reference,
 * and the length of the reference.
 */
template<typename TStr>
void Ebwt<TStr>::joinedToTextOff(uint32_t qlen, uint32_t off,
                                 uint32_t& tidx,
                                 uint32_t& textoff,
                                 uint32_t& tlen,
                                 const EbwtSearchParams<TStr>& params) const
{
	uint32_t ptabOff = (off >> this->_eh._chunkRate)*4;
	uint32_t coff = off & ~(this->_eh._chunkMask);   // offset into chunk
	tidx = this->_pmap[ptabOff];                     // id of text matched
	uint32_t toff = this->_pmap[ptabOff+1];          // offset into sequence
	uint32_t foff = this->_pmap[ptabOff+2];          // offset into fragment
	uint32_t flen = this->_pmap[ptabOff+3];          // fragment length
	assert_lt(tidx, this->_nPat);
	tlen = this->_plen[tidx];

	// Reject if the alignment overlaps this fragment's padding or if
	// it falls off the end of the sequence
	if(foff + coff + qlen > flen) {
		// Spurious result - overlaps with padding after fragment
		tidx = 0xffffffff;
		return;
	}
	// Genuine result
	if(_verbose) {
		cout << "report tidx=" << tidx << ", foff=" << foff << ", absoff=" << off << ", flen=" << flen << endl;
	}
	textoff = toff;
	if(params.ebwtFw()) {
		textoff += (coff+foff);
	} else {
		textoff += (flen - (coff+foff));
		textoff -= qlen;
	}
}
#else
/**
 * Take an offset into the joined text and translate it into the
 * reference of the index it falls on, the offset into the reference,
 * and the length of the reference.  Use a binary search through the
 * sorted list of reference fragment ranges t
 */
template<typename TStr>
void Ebwt<TStr>::joinedToTextOff(uint32_t qlen, uint32_t off,
                                 uint32_t& tidx,
                                 uint32_t& textoff,
                                 uint32_t& tlen,
                                 const EbwtSearchParams<TStr>& params) const
{
	uint32_t top = 0;
	uint32_t bot = _fnum; // 1 greater than largest addressable element
	uint32_t elt = 0xffffffff;
	while(true) {
		uint32_t oldelt = elt;
		elt = (bot - top) >> 1;
		// If these are equal, then we couldn't
		assert_neq(oldelt, elt);
		if(_rstarts[elt] <= off) {
			if(_rstarts[elt+1] > off) {
				// off is in this range; check if it falls off
				if(off + qlen > _rstarts[elt+1]) {
					// it falls off; signal no-go and return
					tidx = 0xffffffff;
					return;
				}
				// it doesn't fall off; now calculate textoff
				textoff = off - _rstarts[elt];
				uint32_t elti = elt;
				// If there's room to walk backwards
				while(elti >= 1) {
					// If the previous fragment range belongs to the
					// same text as this fragment range...
					if(_ftidxs[elti] == _ftidxs[elti-1]) {
						textoff += (_rstarts[elti] - _rstarts[elti-1]);
					}
					elti--;
				}
				break;
			} else {
				// 'off' belongs somewhere in the region between elt
				// and bot
				top = elt;
			}
		} else {
			// 'off' belongs somewhere in the region between top and
			// elt
			bot = elt;
		}
	}
	tlen = this->_plen[tidx];
}
#endif

/**
 * Report a potential match at offset 'off' with pattern length
 * 'qlen'.  We must be careful to filter out spurious matches that
 * fall partially within the padding that separates texts.
 */
template<typename TStr>
inline bool Ebwt<TStr>::report(const String<Dna5>& query,
                               String<char>* quals,
                               String<char>* name,
                               const uint32_t *mmui32,
                               const char *refcs,
                               size_t numMms,
                               uint32_t off,
                               uint32_t top,
                               uint32_t bot,
                               uint32_t qlen,
                               int stratum,
                               const EbwtSearchParams<TStr>& params) const
{
	VMSG_NL("In report");
	assert_lt(off, this->_eh._len);
	if(params.arrowMode()) {
		// Call reportHit with a bogus genome position; in this mode,
		// all we care about are the top and bottom arrows
		return params.reportHit(
				query,               // read sequence
				quals,               // read quality values
				name,                // read name
				mmui32,              // mismatch positions
				refcs,               // reference characters for mms
				numMms,              // # mismatches
				make_pair(0, 0),     // (bogus) position
				make_pair(top, bot), // arrows
				0,                   // (bogus) textlen
				qlen,                // qlen
				stratum,             // alignment stratum
				bot-top-1);          // # other hits
	}

	//
	// Sequences are aligned on chunk boundaries.  Chunk size is
	// configurable with a default of 2K characters.  Sequences are
	// padded to fill the chunks.  Alignments that overlap any padding
	// are invalid and should be weeded out.
	//
	//                 Sequence 0                      Sequence 1
	// -------------------------------------------- -----------------
	// Chunk0   Chunk1   Chunk2   Chunk3   Chunk4   Chunk5   Chunk6
	// ======== ======== ======== ======== ======== ======== ========
	// -------- ----     -------- -------- -        --       -------
	//  Fragment 0  ^^^^      Fragment 1    ^^^^^^^   ^^^^^^
	//              Padding                    Padding
	//
	// To calculate a hit's offset, add the alignment's offset into the
	// fragment containing it with that fragment's offset from the
	// beginning of the sequence.
	//
	uint32_t tidx;
	uint32_t textoff;
	uint32_t tlen;
	joinedToTextOff(qlen, off, tidx, textoff, tlen, params);
	if(tidx == 0xffffffff) {
		return false;
	}
	return params.reportHit(
			query,                    // read sequence
			quals,                    // read quality values
			name,                     // read name
			mmui32,                   // mismatch positions
			refcs,                    // reference characters for mms
			numMms,                   // # mismatches
			make_pair(tidx, textoff), // position
			make_pair(top, bot),      // arrows
			tlen,                     // textlen
			qlen,                     // qlen
			stratum,                  // alignment stratum
			bot-top-1);               // # other hits
}

/**
 * Report a result.  Involves walking backwards along the original
 * string by way of the LF-mapping until we reach a marked SA row or
 * the row corresponding to the 0th suffix.  A marked row's offset
 * into the original string can be read directly from the this->_offs[]
 * array.
 */
template<typename TStr>
inline bool Ebwt<TStr>::reportChaseOne(const String<Dna5>& query,
                                       String<char>* quals,
                                       String<char>* name,
                                       const uint32_t *mmui32,
                                       const char* refcs,
                                       size_t numMms,
                                       uint32_t i,
                                       uint32_t top,
                                       uint32_t bot,
                                       uint32_t qlen,
                                       int stratum,
                                       const EbwtSearchParams<TStr>& params,
                                       SideLocus *l) const
{
	VMSG_NL("In reportChaseOne");
	assert(!params.arrowMode());
	uint32_t off;
	uint32_t jumps = 0;
	SideLocus myl;
	const uint32_t offMask = this->_eh._offMask;
	const uint32_t offRate = this->_eh._offRate;
	const uint32_t* offs = this->_offs;
	if(l == NULL) {
		l = &myl;
		myl.initFromRow(i, this->_eh, this->_ebwt);
	}
	assert(l != NULL);
	// Walk along until we reach the next marked row to the left
	while(((i & offMask) != i) && i != _zOff) {
		// Not a marked row; walk left one more char
		uint32_t newi = mapLF(*l); // calc next row
		assert_neq(newi, i);
		i = newi;                                  // update row
		l->initFromRow(i, this->_eh, this->_ebwt); // update locus
		jumps++;
	}
	// This is a marked row
	if(i == _zOff) {
		// Special case: it's the row corresponding to the
		// lexicographically smallest suffix, which is implicitly
		// marked 0
		off = jumps;
		VMSG_NL("reportChaseOne found zoff off=" << off << " (jumps=" << jumps << ")");
	} else {
		// Normal marked row, calculate offset of row i
		off = offs[i >> offRate] + jumps;
		VMSG_NL("reportChaseOne found off=" << off << " (jumps=" << jumps << ")");
	}
	return report(query, quals, name, mmui32, refcs, numMms, off, top, bot, qlen, stratum, params);
}

/**
 * Transform this Ebwt into the original string in linear time by using
 * the LF mapping to walk backwards starting at the row correpsonding
 * to the end of the string.  The result is written to s.  The Ebwt
 * must be in memory.
 */
template<typename TStr>
void Ebwt<TStr>::restore(TStr& s) const {
	assert(isInMemory());
	resize(s, this->_eh._len, Exact());
	uint32_t jumps = 0;
	uint32_t i = this->_eh._len; // should point to final SA elt (starting with '$')
	SideLocus l(i, this->_eh, this->_ebwt);
	while(i != _zOff) {
		assert_lt(jumps, this->_eh._len);
		//if(_verbose) cout << "restore: i: " << i << endl;
		// Not a marked row; go back a char in the original string
		uint32_t newi = mapLF(l);
		assert_neq(newi, i);
		s[this->_eh._len - jumps - 1] = rowL(l);
		i = newi;
		l.initFromRow(i, this->_eh, this->_ebwt);
		jumps++;
	}
	assert_eq(jumps, this->_eh._len);
}

/**
 * Check that this Ebwt, when restored via restore(), matches up with
 * the given array of reference sequences.  For sanity checking.
 */
template <typename TStr>
void Ebwt<TStr>::checkOrigs(const vector<String<Dna5> >& os,
                            bool mirror) const
{
	TStr rest;
	restore(rest);
	uint32_t restOff = 0;
	size_t i = 0, j = 0;
	if(mirror) {
		// TODO: FIXME
		return;
	}
	while(i < os.size()) {
		size_t olen = length(os[i]);
		for(; j < olen; j++) {
			size_t joff = j;
			if(mirror) joff = olen - j - 1;
			if((int)os[i][joff] == 4) {
				// Skip over Ns
				if(!mirror) {
					while((int)os[i][j] == 4 && j < length(os[i])) j++;
				} else {
					while((int)os[i][olen-j-1] == 4 && j < length(os[i])) j++;
				}
				break;
			}
			assert_eq(os[i][joff], rest[restOff]);
			restOff++;
		}
		if(j == length(os[i])) {
			// Moved to next sequence
			i++;
			j = 0;
		} else {
			// Just jumped over a gap
		}
		uint32_t leftover = (restOff & ~_eh.chunkMask());
		uint32_t diff = _eh.chunkLen() - leftover;
		if(leftover != 0) restOff += diff;
		assert_eq(0, restOff & ~_eh.chunkMask());
	}
}

///////////////////////////////////////////////////////////////////////
//
// Functions for reading and writing Ebwts
//
///////////////////////////////////////////////////////////////////////


/**
 * Read an Ebwt from file with given filename.
 */
template<typename TStr>
EbwtParams Ebwt<TStr>::readIntoMemory(bool justHeader,
                                      const string& in1,
                                      const string& in2)
{
	bool bigEndian; // dummy; caller doesnn't care
	return readIntoMemory(justHeader, in1, in2, bigEndian);
}

/**
 * Read an Ebwt from a file with given filename.  The endianness of the
 * data read is installed in the bigEndian out parameter (true=big).
 */
template<typename TStr>
EbwtParams Ebwt<TStr>::readIntoMemory(bool justHeader,
                                      const string& in1,
                                      const string& in2,
                                      bool& bigEndian)
{
	// Initialize our primary and secondary input-stream fields
	if(!_in1.is_open()) {
		if(this->verbose()) cout << "Opening \"" << in1 << "\"" << endl;
		_in1.open(in1.c_str(), ios_base::in | ios::binary);
		if(!_in1.is_open()) {
			throw EbwtFileOpenException("Cannot open file " + in1);
		}
	}
	assert(_in1.is_open());
	assert(_in1.good());
	assert_eq((streamoff)_in1.tellg(), ios::beg);
	if(!_in2.is_open()) {
		if(this->verbose()) cout << "Opening \"" << in2 << "\"" << endl;
		_in2.open(in2.c_str(), ios_base::in | ios::binary);
		if(!_in2.is_open()) {
			throw EbwtFileOpenException("Cannot open file " + in2);
		}
	}
	assert(_in2.is_open());
	assert(_in2.good());
	assert_eq((streamoff)_in2.tellg(), ios::beg);
	EbwtParams eh(readIntoMemory(justHeader, bigEndian));
	return eh;
}

/**
 * Read an Ebwt into memory (specifically, into the fields of this Ebwt
 * object) from the object's input-stream pair fields.
 */
template<typename TStr>
EbwtParams Ebwt<TStr>::readIntoMemory(bool justHeader) {
	bool bigEndian; // dummy; caller doesn't care
	return readIntoMemory(justHeader, bigEndian);
}

/**
 * Read an Ebwt from an input-stream pair.  The endianness of the data
 * read is installed in the bigEndian out parameter (true=big).  The
 * _in1 and _in2 istreams must already be initialized and open.
 *
 * The caller is responsible for ensuring that both istreams are set up
 * to point just before the Ebwt records.  In most cases, this means
 * that they will both be completely rewound.
 *
 * This function rewinds the streams before returning.
 *
 */
template<typename TStr>
EbwtParams Ebwt<TStr>::readIntoMemory(bool justHeader, bool& be) {
	// _in1 and _in2 must already be open with the get cursor at the
	// beginning and no error flags set.
	assert(_in1.is_open()); assert(_in1.good());
	assert(_in2.is_open()); assert(_in2.good());
	assert_eq((streamoff)_in1.tellg(), ios::beg);
	assert_eq((streamoff)_in2.tellg(), ios::beg);

	if(_verbose) cout << "  Reading header" << endl;

	// Read endianness hints from both streams
	be = false;
	uint32_t one = readU32(_in1, be); // 1st word of primary stream
	#ifndef NDEBUG
	assert_eq(one, readU32(_in2, be)); // should match!
	#else
	readU32(_in2, be);
	#endif
	if(one != 1) {
		assert_eq((1u<<24), one);
		assert_eq(1, endianSwapU32(one));
		be = true;
	}

	// Reads header entries one by one from primary stream
	uint32_t len          = readU32(_in1, be);
	int32_t  lineRate     = readI32(_in1, be);
	int32_t  linesPerSide = readI32(_in1, be);
	int32_t  offRate      = readI32(_in1, be);
	int32_t  ftabChars    = readI32(_in1, be);
	int32_t  chunkRate    = readI32(_in1, be);

	// Create a new EbwtParams from the entries read from primary stream
	EbwtParams eh(len, lineRate, linesPerSide, offRate, ftabChars, chunkRate);
	if(_verbose) eh.print(cout);
	uint32_t offsLen = eh._offsLen;
	uint32_t offRateDiff = 0;
	uint32_t offsLenSampled = offsLen;
	if(_overrideOffRate > offRate) {
		offRateDiff = _overrideOffRate - offRate;
	}
	if(offRateDiff > 0) {
		offsLenSampled >>= offRateDiff;
		if((offsLen & ~(0xffffffff << offRateDiff)) != 0) {
			offsLenSampled++;
		}
	}

	// Read nPat from primary stream
	this->_nPat = readI32(_in1, be);
	try {
		// Read plen from primary stream
		if(_verbose) cout << "Reading plen (" << this->_nPat << ")" << endl;
		this->_plen = new uint32_t[this->_nPat];
		if(be) {
			for(uint32_t i = 0; i < this->_nPat; i++) {
				this->_plen[i] = readU32(_in1, be);
			}
		} else {
			_in1.read((char *)this->_plen, this->_nPat*4);
			assert_eq(this->_nPat*4, (uint32_t)_in1.gcount());
		}
		for(uint32_t i = 0; i < this->_nPat; i++) {
			// Following is not necessarily true because we
			// intentionally don't count gaps and ambiguous chars on
			// the end of a sequence towards its plen
			//assert_leq(this->_plen[i], len);
			// Following is not necessarily true because we keep
			// entries around for empty or all-gap sequeneces
			//assert_gt(this->_plen[i], 0);
		}
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating plen[] in Ebwt::read()"
		     << " at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}

	// TODO: I'm not consistent on what "header" means.  Here I'm using
	// "header" to mean everything that would exist in memory if we
	// started to build the Ebwt but stopped short of the build*() step
	// (i.e. everything up to and including join()).
	if(justHeader) goto done;

	// Read pmap from primary stream
	try {
		uint32_t pmapEnts = eh._numChunks*4;
		if(_verbose) cout << "Reading pmap (" << pmapEnts << ")" << endl;
		this->_pmap = new uint32_t[pmapEnts];
		if(be) {
			for(uint32_t i = 0; i < pmapEnts; i += 4) {
				this->_pmap[i]   = readU32(_in1, be); // pat #
				this->_pmap[i+1] = readU32(_in1, be); // sequence offset
				this->_pmap[i+2] = readU32(_in1, be); // fragment offset
				this->_pmap[i+3] = readU32(_in1, be); // fragment length
			}
		} else {
			_in1.read((char *)this->_pmap, pmapEnts*4);
			assert_eq(pmapEnts*4, (uint32_t)_in1.gcount());
		}
		for(uint32_t i = 0; i < pmapEnts; i += 4) {
			assert_lt (this->_pmap[i],   this->_nPat);
			assert_lt (this->_pmap[i+1], this->_plen[this->_pmap[i]]);
			assert_lt (this->_pmap[i+2], this->_pmap[i+3]);
			assert_leq(this->_pmap[i+3], this->_plen[this->_pmap[i]]);
		}
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating pmap[] in Ebwt::read()"
		     << " at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}

	// Allocate ebwt (big allocation)
	if(_verbose) cout << "Reading ebwt (" << eh._ebwtTotLen << ")" << endl;
	try {
		this->_ebwt = new uint8_t[eh._ebwtTotLen];
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating ebwt[] in Ebwt::read()"
		     << " at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}
	// Read ebwt from primary stream
	_in1.read((char *)this->_ebwt, eh._ebwtTotLen);
	assert_eq(eh._ebwtTotLen, (uint32_t)_in1.gcount());

	// Read zOff from primary stream
	_zOff = readU32(_in1, be);
	assert_lt(_zOff, len);

	try {
		// Read fchr from primary stream
		if(_verbose) cout << "Reading fchr (5)" << endl;
		this->_fchr = new uint32_t[5];
		for(int i = 0; i < 5; i++) {
			this->_fchr[i] = readU32(_in1, be);
			assert_leq(this->_fchr[i], len);
			if(i > 0) assert_geq(this->_fchr[i], this->_fchr[i-1]);
		}
		// Read ftab from primary stream
		if(_verbose) cout << "Reading ftab (" << eh._ftabLen << ")" << endl;
		this->_ftab = new uint32_t[eh._ftabLen];
		if(be) {
			for(uint32_t i = 0; i < eh._ftabLen; i++)
				this->_ftab[i] = readU32(_in1, be);
		} else {
			_in1.read((char *)this->_ftab, eh._ftabLen*4);
			assert_eq(eh._ftabLen*4, (uint32_t)_in1.gcount());
		}
		// Read etab from primary stream
		if(_verbose) cout << "Reading eftab (" << eh._eftabLen << ")" << endl;
		this->_eftab = new uint32_t[eh._eftabLen];
		if(be) {
			for(uint32_t i = 0; i < eh._eftabLen; i++)
				this->_eftab[i] = readU32(_in1, be);
		} else {
			_in1.read((char *)this->_eftab, eh._eftabLen*4);
			assert_eq(eh._eftabLen*4, (uint32_t)_in1.gcount());
		}
		for(uint32_t i = 0; i < eh._eftabLen; i++) {
			if(i > 0 && this->_eftab[i] > 0) {
				assert_geq(this->_eftab[i], this->_eftab[i-1]);
			} else if(i > 0 && this->_eftab[i-1] == 0) {
				assert_eq(0, this->_eftab[i]);
			}
		}
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating fchr[], ftab[] or eftab[] in "
		     << "Ebwt::read()  at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}

	// Read reference sequence names from primary index file
	while(true) {
		char c = '\0';
		_in1.read(&c, 1);
		if(_in1.eof()) break;
		if(c == '\0') break;
		else if(c == '\n') {
			this->_refnames.push_back("");
		} else {
			if(this->_refnames.size() == 0) {
				this->_refnames.push_back("");
			}
			this->_refnames.back().push_back(c);
		}
	}

	// Allocate offs (big allocation)
	try {
		if(_verbose) cout << "Reading offs (" << offsLenSampled << ")" << endl;
		this->_offs = new uint32_t[offsLenSampled];
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating offs[] in Ebwt::read()"
		     << " at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}
	if(be || offRateDiff > 0) {
		for(uint32_t i = 0; i < offsLen; i++) {
			if((i & ~(0xffffffff << offRateDiff)) != 0) {
				char tmp[4];
				_in2.read(tmp, 4);
			} else {
				uint32_t idx = i >> offRateDiff;
				assert_lt(idx, offsLenSampled);
				this->_offs[idx] = readU32(_in2, be);
			}
		}
		//eh._offRate = _overrideOffRate;
		//eh._offMask = (0xffffffff << _overrideOffRate);
	} else {
		_in2.read((char *)this->_offs, offsLen*4);
		assert_eq(offsLen*4, (uint32_t)_in2.gcount());
	}
	for(uint32_t i = 0; i < offsLenSampled; i++) {
		assert_leq(this->_offs[i], len);
	}

	postReadInit(eh); // Initialize fields of Ebwt not read from file
	if(_verbose) print(cout, eh);

	// The fact that _ebwt and friends actually point to something
	// (other than NULL) now signals to other member functions that the
	// Ebwt is loaded into memory.

  done: // Exit hatch for both justHeader and !justHeader

	// Be kind
	_in1.clear(); _in1.seekg(0, ios::beg);
	_in2.clear(); _in2.seekg(0, ios::beg);
	assert(_in1.is_open()); assert(_in1.good());
	assert(_in2.is_open()); assert(_in2.good());
	return eh;
}

/**
 * Write an extended Burrows-Wheeler transform to a pair of output
 * streams.
 *
 * @param out1 output stream to primary file
 * @param out2 output stream to secondary file
 * @param be   write in big endian?
 */
template<typename TStr>
void Ebwt<TStr>::writeFromMemory(bool justHeader,
                                 ostream& out1,
                                 ostream& out2) const
{
	const EbwtParams& eh = this->_eh;
	assert(eh.repOk());
	uint32_t be = this->toBe();
	assert(out1.good());
	assert(out2.good());

	// When building an Ebwt, these header parameters are known
	// "up-front", i.e., they can be written to disk immediately,
	// before we join() or buildToDisk()
	writeI32(out1, 1, be); // endian hint for priamry stream
	writeI32(out2, 1, be); // endian hint for secondary stream
	writeU32(out1, eh._len,          be); // length of string (and bwt and suffix array)
	writeI32(out1, eh._lineRate,     be); // 2^lineRate = size in bytes of 1 line
	writeI32(out1, eh._linesPerSide, be); // not used
	writeI32(out1, eh._offRate,      be); // every 2^offRate chars is "marked"
	writeI32(out1, eh._ftabChars,    be); // number of 2-bit chars used to address ftab
	writeI32(out1, eh._chunkRate,    be);

	if(!justHeader) {
		assert(isInMemory());
		// These Ebwt parameters are known after the inputs strings have
		// been joined() but before they have been built().  These can
		// written to the disk next and then discarded from memory.
		writeU32(out1, this->_nPat,      be);
		for(uint32_t i = 0; i < this->_nPat; i++)
		writeU32(out1, this->_plen[i], be);
		for(uint32_t i = 0; i < eh._numChunks*4; i++)
			writeU32(out1, this->_pmap[i], be);

		// These Ebwt parameters are discovered only as the Ebwt is being
		// built (in buildToDisk()).  Of these, only 'offs' and 'ebwt' are
		// terribly large.  'ebwt' is written to the primary file and then
		// discarded from memory as it is built; 'offs' is similarly
		// written to the secondary file and discarded.
		out1.write((const char *)this->ebwt(), eh._ebwtTotLen);
		writeU32(out1, this->zOff(), be);
		uint32_t offsLen = eh._offsLen;
		for(uint32_t i = 0; i < offsLen; i++)
			writeU32(out2, this->_offs[i], be);

		// 'fchr', 'ftab' and 'eftab' are not fully determined until the
		// loop is finished, so they are written to the primary file after
		// all of 'ebwt' has already been written and only then discarded
		// from memory.
		for(int i = 0; i < 5; i++)
			writeU32(out1, this->_fchr[i], be);
		for(uint32_t i = 0; i < eh._ftabLen; i++)
			writeU32(out1, this->ftab()[i], be);
		for(uint32_t i = 0; i < eh._eftabLen; i++)
			writeU32(out1, this->eftab()[i], be);
	}
}

/**
 * Given a pair of strings representing output filenames, and assuming
 * this Ebwt object is currently in memory, write out this Ebwt to the
 * specified files.
 *
 * If sanity-checking is enabled, then once the streams have been
 * fully written and closed, we reopen them and read them into a
 * (hopefully) exact copy of this Ebwt.  We then assert that the
 * current Ebwt and the copy match in all of their fields.
 */
template<typename TStr>
void Ebwt<TStr>::writeFromMemory(bool justHeader,
                                 const string& out1,
                                 const string& out2) const
{
	const EbwtParams& eh = this->_eh;
	assert(isInMemory());
	assert(eh.repOk());

	ofstream fout1(out1.c_str(), ios::binary);
	ofstream fout2(out2.c_str(), ios::binary);
	writeFromMemory(justHeader, fout1, fout2);
	fout1.close();
	fout2.close();

	// Read the file back in and assert that all components match
	if(_sanity) {
		if(_verbose)
			cout << "Re-reading \"" << out1 << "\"/\"" << out2 << "\" for sanity check" << endl;
		Ebwt copy(out1, out2, _verbose, _sanity);
		assert(!isInMemory());
		copy.loadIntoMemory();
		assert(isInMemory());
	    assert_eq(eh._lineRate,     copy.eh()._lineRate);
	    assert_eq(eh._linesPerSide, copy.eh()._linesPerSide);
	    assert_eq(eh._offRate,      copy.eh()._offRate);
	    assert_eq(eh._ftabChars,    copy.eh()._ftabChars);
	    assert_eq(eh._len,          copy.eh()._len);
	    assert_eq(eh._chunkRate,    copy.eh()._chunkRate);
	    assert_eq(_zOff,             copy.zOff());
	    assert_eq(_zEbwtBpOff,       copy.zEbwtBpOff());
	    assert_eq(_zEbwtByteOff,     copy.zEbwtByteOff());
		assert_eq(_nPat,             copy.nPat());
		for(uint32_t i = 0; i < _nPat; i++)
			assert_eq(this->_plen[i], copy.plen()[i]);
		for(uint32_t i = 0; i < eh._numChunks*4; i++)
			assert_eq(this->_pmap[i], copy.pcap()[i]);
		for(uint32_t i = 0; i < 5; i++)
			assert_eq(this->_fchr[i], copy.fchr()[i]);
		for(uint32_t i = 0; i < eh._ftabLen; i++)
			assert_eq(this->ftab()[i], copy.ftab()[i]);
		for(uint32_t i = 0; i < eh._eftabLen; i++)
			assert_eq(this->eftab()[i], copy.eftab()[i]);
		for(uint32_t i = 0; i < eh._offsLen; i++)
			assert_eq(this->_offs[i], copy.offs()[i]);
		for(uint32_t i = 0; i < eh._ebwtTotLen; i++)
			assert_eq(this->ebwt()[i], copy.ebwt()[i]);
		copy.sanityCheckAll();
		if(_verbose)
			cout << "Read-in check passed for \"" << out1 << "\"/\"" << out2 << "\"" << endl;
	}
}

///////////////////////////////////////////////////////////////////////
//
// Functions for building Ebwts
//
///////////////////////////////////////////////////////////////////////

/**
 * Join several text strings together in a way that's compatible with
 * the text-chunking scheme dictated by chunkRate parameter.
 *
 * The non-static member Ebwt::join additionally builds auxilliary
 * arrays that maintain a mapping between chunks in the joined string
 * and the original text strings.
 */
template<typename TStr>
TStr Ebwt<TStr>::join(vector<TStr>& l, uint32_t chunkRate, uint32_t seed) {
	RandomSource rand(seed); // reproducible given same seed
	uint32_t chunkLen = 1 << chunkRate;
	uint32_t chunkMask = 0xffffffff << chunkRate;
	TStr ret;
	size_t guessLen = 0;
	for(size_t i = 0; i < l.size(); i++) {
		guessLen += length(l[i]) + chunkLen;
	}
	reserve(ret, guessLen, Exact());
	for(size_t i = 0; i < l.size(); i++) {
		TStr& s = l[i];
		assert_gt(length(s), 0);
		append(ret, s);
		// s isn't the last pattern; padding between s and the next
		// pattern may be necessary
		uint32_t diff = 0;
		uint32_t leftover = length(ret) & ~chunkMask;
		if(leftover > 0) {
			// The joined string currently ends in the middle of a
			// chunk, so we have to pad it by 'diff'
			diff = chunkLen - leftover;
			assert_gt(diff, 0);
		}
		for(size_t j = 0; j < diff; j++) {
			// Append random characters to fill the gap; note that
			// the randomness is reproducible as long as the 'seed'
			// argument is the same, which helps us to sanity-check
			// the result.
			appendValue(ret, (Dna)(rand.nextU32() & 3)); // append random junk
			assert_lt((uint8_t)ret[length(ret)-1], 4);
		}
		// Padded pattern ends on a chunk boundary
		assert_eq(length(ret), length(ret) & chunkMask);
	}
	return ret;
}

/**
 * Join several text strings together in a way that's compatible with
 * the text-chunking scheme dictated by chunkRate parameter.
 *
 * The non-static member Ebwt::join additionally builds auxilliary
 * arrays that maintain a mapping between chunks in the joined string
 * and the original text strings.
 */
template<typename TStr>
TStr Ebwt<TStr>::join(vector<istream*>& l,
                      vector<RefRecord>& szs,
                      uint32_t sztot,
                      const RefReadInParams& refparams,
                      uint32_t chunkRate,
                      uint32_t seed)
{
	RandomSource rand(seed); // reproducible given same seed
	RefReadInParams rpcp = refparams;
	uint32_t chunkLen = 1 << chunkRate;
	uint32_t chunkMask = 0xffffffff << chunkRate;
	TStr ret;
	size_t guessLen = sztot + (szs.size() * chunkLen);
	reserve(ret, guessLen, Exact());
	ASSERT_ONLY(size_t szsi = 0);
	for(size_t i = 0; i < l.size(); i++) {
		// For each sequence we can pull out of istream l[i]...
		assert(l[i]->good());
		bool first = true;
		assert_geq(rpcp.numSeqCutoff, -1);
		assert_geq(rpcp.baseCutoff, -1);
		while(l[i]->good() && !l[i]->eof() && rpcp.numSeqCutoff != 0 && rpcp.baseCutoff != 0) {
			RefRecord rec = fastaRefReadAppend(*l[i], first, ret, rpcp);
			first = false;
			size_t bases = rec.len;
			assert_eq(rec.off, szs[szsi].off);
			assert_eq(rec.len, szs[szsi].len);
			assert_eq(rec.first, szs[szsi].first);
			ASSERT_ONLY(szsi++);
			if(bases == 0) continue;
			if(rpcp.numSeqCutoff != -1) rpcp.numSeqCutoff--;
			if(rpcp.baseCutoff != -1)   rpcp.baseCutoff -= bases;
			assert_geq(rpcp.numSeqCutoff, -1);
			assert_geq(rpcp.baseCutoff, -1);
		    // insert padding
			uint32_t diff = 0;
			uint32_t rlen = length(ret);
			uint32_t leftover = rlen & ~chunkMask;
			if(leftover > 0) {
				// The joined string currently ends in the middle of a
				// chunk, so we have to pad it by 'diff'
				diff = chunkLen - leftover;
				assert_gt(diff, 0);
			}
			for(uint32_t i = 0; i < diff; i++) {
				// Append random characters to fill the gap; note that
				// the randomness is reproducible as long as the 'seed'
				// argument is the same, which helps us to sanity-check
				// the result.
				appendValue(ret, (Dna)(rand.nextU32() & 3));
				assert_lt((uint8_t)(Dna)ret[length(ret)-1], 4);
			}
			// Pattern now ends on a chunk boundary
			assert_eq(length(ret), length(ret) & chunkMask);
		}
	}
	return ret;
}

/**
 * Join several text strings together according to the text-chunking
 * scheme specified in the EbwtParams.  Ebwt fields calculated in this
 * function (_nPat, _plen, _pmap) are written directly to disk.  The
 * _nPat and _plen fields are also retained in the Ebwt, but the _pmap
 * field is not.  _pmap is relatively big, so we avoid keeping it in
 * memory unless the user specifically loads the Ebwt.
 *
 * It is assumed, but not required, that the header values have already
 * been written to 'out1' before this function is called.
 *
 * The static member Ebwt::join just returns a joined version of a
 * list of strings without building any of the auxilliary arrays.
 * Because the pseudo-random number generator is the same, we expect
 * this function and the static function to give the same result given
 * the same seed.
 */
template<typename TStr>
void Ebwt<TStr>::joinToDisk(vector<istream*>& l,
                            vector<RefRecord>& szs,
                            uint32_t sztot,
                            const RefReadInParams& refparams,
                            TStr& ret,
                            ostream& out1,
                            ostream& out2,
                            uint32_t seed = 0)
{
	RandomSource rand(seed); // reproducible given same seed
	const EbwtParams& eh = this->_eh;
	RefReadInParams rpcp = refparams;
	assert_gt(szs.size(), 0);
	assert_gt(l.size(), 0);
	assert_gt(sztot, 0);
	// Not every fragment represents a distinct sequence - many
	// fragments may correspond to a single sequence.  Count the
	// number of sequences here by counting the number of "first"
	// fragments.
	size_t npats = 0;
	for(size_t i = 0; i < szs.size(); i++) {
		if(szs[i].first) npats++;
	}
	assert_gt(npats, 0);
	this->_nPat = npats; // store this in memory
	this->_pmap = NULL;
	writeU32(out1, this->_nPat, this->toBe());
	ASSERT_ONLY(uint32_t pmapEnts = eh._numChunks*4);
	uint32_t pmapOff = 0;
	// Allocate plen[]
	try {
		this->_plen = new uint32_t[this->_nPat];
	} catch(bad_alloc& e) {
		cerr << "Out of memory allocating plen[] in Ebwt::join()"
		     << " at " << __FILE__ << ":" << __LINE__ << endl;
		throw e;
	}
	// For each pattern, set plen
	int npat = -1;
	assert(szs[0].first);
	for(size_t i = 0; i < szs.size(); i++) {
		if(szs[i].first) {
			if(npat >= 0) {
				writeU32(out1, this->_plen[npat], this->toBe());
			}
			npat++;
			this->_plen[npat] = (szs[i].len + szs[i].off);
		} else {
			this->_plen[npat] += (szs[i].len + szs[i].off);
		}
	}
	assert_eq((uint32_t)npat, this->_nPat-1);
	writeU32(out1, this->_plen[npat], this->toBe());

	size_t seqsRead = 0;
	ASSERT_ONLY(uint32_t szsi = 0);
	for(unsigned int i = 0; i < l.size(); i++) {
		assert(l[i]->good());
		bool first = true;
		streampos pos = l[i]->tellg();
		assert_geq(rpcp.numSeqCutoff, -1);
		assert_geq(rpcp.baseCutoff, -1);
		uint32_t patoff = 0;
		// For each *fragment* (not necessary an entire sequence) we
		// can pull out of istream l[i]...
		while(l[i]->good() && !l[i]->eof() && rpcp.numSeqCutoff != 0 && rpcp.baseCutoff != 0) {
			string name;
			// Push a new name onto our vector
			_refnames.push_back("");
			RefRecord rec = fastaRefReadAppend(*l[i], first, ret, rpcp, &_refnames.back());
			first = false;
			size_t bases = rec.len;
			if(rec.first) {
				if(_refnames.back().length() == 0) {
					// If name was empty, replace with an index
					ostringstream stm;
					stm << seqsRead;
					_refnames.back() = stm.str();
				}
			} else {
				assert_eq(0, _refnames.back().length());
				_refnames.pop_back();
			}
			assert_lt(szsi, szs.size());
			assert_eq(rec.off, szs[szsi].off);
			assert_eq(rec.len, szs[szsi].len);
			assert_eq(rec.first, szs[szsi].first);
			assert(rec.first || rec.off > 0);
			ASSERT_ONLY(szsi++);
			// Increment seqsRead if this is the first fragment
			if(rec.first) seqsRead++;
			if(bases == 0) continue;
			assert_leq(bases, this->_plen[seqsRead-1]);
			// Reset the patoff if this is the first fragment
			if(rec.first) patoff = 0;
			patoff += rec.off; // add fragment's offset from end of last frag.
			// Adjust rpcps
			if(rpcp.numSeqCutoff != -1) rpcp.numSeqCutoff--;
			if(rpcp.baseCutoff != -1)   rpcp.baseCutoff -= bases;
			assert_geq(rpcp.numSeqCutoff, -1);
			assert_geq(rpcp.baseCutoff, -1);

		    // insert padding
			uint32_t diff = 0;
			uint32_t rlen = length(ret);
			uint32_t leftover = rlen & ~(eh._chunkMask);
			if(leftover > 0) {
				// The joined string currently ends in the middle of a
				// chunk, so we have to pad it by 'diff'
				diff = eh._chunkLen - leftover;
				assert_gt(diff, 0);
			}
			for(uint32_t i = 0; i < diff; i++) {
				// Append random characters to fill the gap; note that
				// the randomness is reproducible as long as the 'seed'
				// argument is the same, which helps us to sanity-check
				// the result.
				appendValue(ret, (Dna)(rand.nextU32() & 3)); // append random junk
				assert_lt((uint8_t)(Dna)ret[length(ret)-1], 4);
			}
			// Pattern now ends on a chunk boundary
			assert_eq(length(ret), length(ret) & eh._chunkMask);
			// Initialize elements of the pmap that cover this pattern
			for(unsigned int j = 0; j < bases; j += eh._chunkLen) {
				assert_lt(pmapOff+3, pmapEnts);
				pmapOff += 4;
				uint32_t seq = seqsRead-1;
				writeU32(out1, seq,    this->toBe()); // sequence id
				writeU32(out1, patoff, this->toBe()); // offset into sequence
				writeU32(out1, j,      this->toBe()); // offset into fragment
				writeU32(out1, bases,  this->toBe()); // fragment length
			}
			patoff += bases;
		}
		assert_gt(szsi, 0);
		l[i]->clear();
		l[i]->seekg(pos);
		assert(!l[i]->bad());
		assert(!l[i]->fail());
		l[i]->clear();
		assert(l[i]->good());
		assert(!l[i]->eof());
		#ifndef NDEBUG
		int c = l[i]->get();
		assert_eq('>', c);
		assert(l[i]->good());
		assert(!l[i]->eof());
		l[i]->seekg(pos);
		l[i]->clear();
		assert(l[i]->good());
		assert(!l[i]->eof());
		#endif
	}
	assert_eq(pmapOff, pmapEnts); // initialized every pmap element
}


/**
 * Build an Ebwt from a string 's' and its suffix array 'sa' (which
 * might actually be a suffix array *builder* that builds blocks of the
 * array on demand).  The bulk of the Ebwt, i.e. the ebwt and offs
 * arrays, is written directly to disk.  This is by design: keeping
 * those arrays in memory needlessly increases the footprint of the
 * building process.  Instead, we prefer to build the Ebwt directly
 * "to disk" and then read it back into memory later as necessary.
 *
 * It is assumed that the header values and join-related values (nPat,
 * plen, pmap) have already been written to 'out1' before this function
 * is called.  When this function is finished, it will have
 * additionally written ebwt, zOff, fchr, ftab and eftab to the primary
 * file and offs to the secondary file.
 *
 * Assume DNA/RNA/any alphabet with 4 or fewer elements.
 * Assume occ array entries are 32 bits each.
 *
 * @param sa            the suffix array to convert to a Ebwt
 * @param s             the original string
 * @param out
 */
template<typename TStr>
void Ebwt<TStr>::buildToDisk(InorderBlockwiseSA<TStr>& sa,
                             const TStr& s,
                             ostream& out1,
                             ostream& out2)
{
	const EbwtParams& eh = this->_eh;

	assert(eh.repOk());
	assert_eq(length(s)+1, sa.size());
	assert_eq(length(s), eh._len);
	assert_gt(eh._lineRate, 3);
	assert(sa.suffixItrIsReset());
	assert_leq((int)ValueSize<Dna>::VALUE, 4);

	uint32_t  len = eh._len;
	uint32_t  ftabLen = eh._ftabLen;
	uint32_t  sideSz = eh._sideSz;
	uint32_t  ebwtTotSz = eh._ebwtTotSz;
	uint32_t  fchr[] = {0, 0, 0, 0, 0};
	uint32_t* ftab = NULL;
	uint32_t  zOff = 0xffffffff;

	// Save # of occurrences of each character as we walk along the bwt
	uint32_t occ[4] = {0, 0, 0, 0};
	// Save 'G' and 'T' occurrences between backward and forward buckets
	uint32_t occSave[2] = {0, 0};

	// Record rows that should "absorb" adjacent rows in the ftab.
	// The absorbed rows represent suffixes shorter than the ftabChars
	// cutoff.
	uint8_t absorbCnt = 0;
	uint8_t *absorbFtab;
	try {
		VMSG_NL("Allocating ftab, absorbFtab");
		ftab = new uint32_t[ftabLen];
		memset(ftab, 0, 4 * ftabLen);
		absorbFtab = new uint8_t[ftabLen];
		memset(absorbFtab, 0, ftabLen);
	} catch(bad_alloc &e) {
		cerr << "Out of memory allocating ftab[] or absorbFtab[] "
		     << "in Ebwt::buildToDisk() at " << __FILE__ << ":"
		     << __LINE__ << endl;
		throw e;
	}
	assert(ftab != NULL);
	assert(absorbFtab != NULL);

	// Allocate the side buffer; holds a single side as its being
	// constructed and then written to disk.  Reused across all sides.
	uint8_t *ebwtSide = NULL;
	try {
		ebwtSide = new uint8_t[sideSz];
	} catch(bad_alloc &e) {
		cerr << "Out of memory allocating ebwtSide[] in "
		     << "Ebwt::buildToDisk() at " << __FILE__ << ":"
		     << __LINE__ << endl;
		throw e;
	}
	assert(ebwtSide != NULL);

	// Points to the base offset within ebwt for the side currently
	// being written
	uint32_t side = 0;
	// Points to a byte offset from 'side' within ebwt[] where next
	// char should be written
	int sideCur = eh._sideBwtSz - 1;

	// Whether we're assembling a forward or a reverse bucket
	bool fw = false;

	// Did we just finish writing a forward bucket?  (Must be true when
	// we exit the loop.)
	bool wroteFwBucket = false;

	// Have we skipped the '$' in the last column yet?
	ASSERT_ONLY(bool dollarSkipped = false);

	uint32_t si = 0;   // string offset (chars)
	ASSERT_ONLY(uint32_t lastSufInt = 0);
	ASSERT_ONLY(bool inSA = true); // true iff saI still points inside suffix
	                               // array (as opposed to the padding at the
	                               // end)
	// Iterate over packed bwt bytes
	VMSG_NL("Entering Ebwt loop");
	ASSERT_ONLY(uint32_t beforeEbwtOff = (uint32_t)out1.tellp());
	while(side < ebwtTotSz) {
		wroteFwBucket = false;
		// Sanity-check our cursor into the side buffer
		assert_geq(sideCur, 0);
		assert_lt(sideCur, (int)eh._sideBwtSz);
		assert_eq(0, side % sideSz); // 'side' must be on side boundary
		ebwtSide[sideCur] = 0; // clear
		assert_lt(side + sideCur, ebwtTotSz);
		// Iterate over bit-pairs in the si'th character of the BWT
		for(int bpi = 0; bpi < 4; bpi++, si++) {
			int bwtChar;
			bool count = true;
			if(si <= len) {
				// Still in the SA; extract the bwtChar
				uint32_t saElt = sa.nextSuffix();
				// (that might have triggered sa to calc next suf block)
				if(saElt == 0) {
					// Don't add the '$' in the last column to the BWT
					// transform; we can't encode a $ (only A C T or G)
					// and counting it as, say, an A, will mess up the
					// LR mapping
					bwtChar = 0; count = false;
					ASSERT_ONLY(dollarSkipped = true);
					zOff = si; // remember the SA row that
					           // corresponds to the 0th suffix
				} else {
					bwtChar = (int)(Dna)(s[saElt-1]);
					assert_lt(bwtChar, 4);
					// Update the fchr
					fchr[bwtChar]++;
				}
				// Update ftab
				if((len-saElt) >= (uint32_t)eh._ftabChars) {
					// Turn the first ftabChars characters of the
					// suffix into an integer index into ftab
					uint32_t sufInt = 0;
					for(int i = 0; i < eh._ftabChars; i++) {
						sufInt <<= 2;
						assert_lt(i, (int)(len-saElt));
						sufInt |= (unsigned char)(Dna)(s[saElt+i]);
					}
					// Assert that this prefix-of-suffix is greater
					// than or equal to the last one (true b/c the
					// suffix array is sorted)
					#ifndef NDEBUG
					if(lastSufInt > 0) assert_geq(sufInt, lastSufInt);
					lastSufInt = sufInt;
					#endif
					// Update ftab
					assert_lt(sufInt+1, ftabLen);
					ftab[sufInt+1]++;
					if(absorbCnt > 0) {
						// Absorb all short suffixes since the last
						// transition into this transition
						absorbFtab[sufInt] = absorbCnt;
						absorbCnt = 0;
					}
				} else {
					// Otherwise if suffix is fewer than ftabChars
					// characters long, then add it to the 'absorbCnt';
					// it will be absorbed into the next transition
					assert_lt(absorbCnt, 255);
					absorbCnt++;
				}
				// Offset boundary? - update offset array
				if((si & eh._offMask) == si) {
					assert_lt((si >> eh._offRate), eh._offsLen);
					// Write offsets directly to the secondary output
					// stream, thereby avoiding keeping them in memory
					writeU32(out2, saElt, this->toBe());
				}
			} else {
				// Strayed off the end of the SA, now we're just
				// padding out a bucket
				#ifndef NDEBUG
				if(inSA) {
					// Assert that we wrote all the characters in the
					// string before now
					assert_eq(si, len+1);
					inSA = false;
				}
				#endif
				// 'A' used for padding; important that padding be
				// counted in the occ[] array
				bwtChar = 0;
			}
			if(count) occ[bwtChar]++;
			// Append BWT char to bwt section of current side
			if(fw) {
				// Forward bucket: fill from least to most
				pack_2b_in_8b(bwtChar, ebwtSide[sideCur], bpi);
				assert_eq((ebwtSide[sideCur] >> (bpi*2)) & 3, bwtChar);
			} else {
				// Backward bucket: fill from most to least
				pack_2b_in_8b(bwtChar, ebwtSide[sideCur], 3-bpi);
				assert_eq((ebwtSide[sideCur] >> ((3-bpi)*2)) & 3, bwtChar);
			}
		} // end loop over bit-pairs
		assert_eq(dollarSkipped ? 3 : 0, (occ[0] + occ[1] + occ[2] + occ[3]) & 3);
		assert_eq(0, si & 3);
		if(fw) sideCur++;
		else   sideCur--;
		if(sideCur == (int)eh._sideBwtSz) {
			// Forward side boundary
			assert_eq(0, si % eh._sideBwtLen);
			sideCur = eh._sideBwtSz - 1;
			assert(fw); fw = false; wroteFwBucket = true;
			// Write 'G' and 'T'
			assert_leq(occSave[0], occ[2]);
			assert_leq(occSave[1], occ[3]);
			uint32_t *u32side = reinterpret_cast<uint32_t*>(ebwtSide);
			side += sideSz;
			assert_leq(side, eh._ebwtTotSz);
			u32side[(sideSz >> 2)-2] = endianizeU32(occSave[0], this->toBe());
			u32side[(sideSz >> 2)-1] = endianizeU32(occSave[1], this->toBe());
			// Write forward side to primary file
			out1.write((const char *)ebwtSide, sideSz);
		} else if (sideCur == -1) {
			// Backward side boundary
			assert_eq(0, si % eh._sideBwtLen);
			sideCur = 0;
			assert(!fw); fw = true;
			// Write 'A' and 'C'
			uint32_t *u32side = reinterpret_cast<uint32_t*>(ebwtSide);
			side += sideSz;
			assert_leq(side, eh._ebwtTotSz);
			u32side[(sideSz >> 2)-2] = endianizeU32(occ[0], this->toBe());
			u32side[(sideSz >> 2)-1] = endianizeU32(occ[1], this->toBe());
			occSave[0] = occ[2]; // save 'G' count
			occSave[1] = occ[3]; // save 'T' count
			// Write backward side to primary file
			out1.write((const char *)ebwtSide, sideSz);
		}
	}
	VMSG_NL("Exited Ebwt loop");
	assert(ftab != NULL);
	assert_neq(zOff, 0xffffffff);
	if(absorbCnt > 0) {
		// Absorb any trailing, as-yet-unabsorbed short suffixes into
		// the last element of ftab
		absorbFtab[ftabLen-1] = absorbCnt;
	}
	// Assert that our loop counter got incremented right to the end
	assert_eq(side, eh._ebwtTotSz);
	// Assert that we wrote the expected amount to out1
	assert_eq(((uint32_t)out1.tellp() - beforeEbwtOff), eh._ebwtTotSz);
	// assert that the last thing we did was write a forward bucket
	assert(wroteFwBucket);

	//
	// Write zOff to primary stream
	//
	writeU32(out1, zOff, this->toBe());

	//
	// Finish building fchr
	//
	// Exclusive prefix sum on fchr
	for(int i = 1; i < 4; i++) {
		fchr[i] += fchr[i-1];
	}
	assert_eq(fchr[3], len);
	// Shift everybody up by one
	for(int i = 4; i >= 1; i--) {
		fchr[i] = fchr[i-1];
	}
	fchr[0] = 0;
	if(_verbose) {
		for(int i = 0; i < 5; i++)
			cout << "fchr[" << "ACGT$"[i] << "]: " << fchr[i] << endl;
	}
	// Write fchr to primary file
	for(int i = 0; i < 5; i++) {
		writeU32(out1, fchr[i], this->toBe());
	}

	//
	// Finish building ftab and build eftab
	//
	// Prefix sum on ftable
	uint32_t eftabLen = 0;
	assert_eq(0, absorbFtab[0]);
	for(uint32_t i = 1; i < ftabLen; i++) {
		if(absorbFtab[i] > 0) eftabLen += 2;
	}
	assert_leq(eftabLen, (uint32_t)eh._ftabChars*2);
	eftabLen = eh._ftabChars*2;
	uint32_t *eftab = NULL;
	try {
		eftab = new uint32_t[eftabLen];
		memset(eftab, 0, 4 * eftabLen);
	} catch(bad_alloc &e) {
		cerr << "Out of memory allocating eftab[] "
		     << "in Ebwt::buildToDisk() at " << __FILE__ << ":"
		     << __LINE__ << endl;
		throw e;
	}
	assert(eftab != NULL);
	uint32_t eftabCur = 0;
	for(uint32_t i = 1; i < ftabLen; i++) {
		uint32_t lo = ftab[i] + Ebwt::ftabHi(ftab, eftab, len, ftabLen, eftabLen, i-1);
		if(absorbFtab[i] > 0) {
			// Skip a number of short pattern indicated by absorbFtab[i]
			uint32_t hi = lo + absorbFtab[i];
			assert_lt(eftabCur*2+1, eftabLen);
			eftab[eftabCur*2] = lo;
			eftab[eftabCur*2+1] = hi;
			ftab[i] = (eftabCur++) ^ 0xffffffff; // insert pointer into eftab
			assert_eq(lo, Ebwt::ftabLo(ftab, eftab, len, ftabLen, eftabLen, i));
			assert_eq(hi, Ebwt::ftabHi(ftab, eftab, len, ftabLen, eftabLen, i));
		} else {
			ftab[i] = lo;
		}
	}
	assert_eq(Ebwt::ftabHi(ftab, eftab, len, ftabLen, eftabLen, ftabLen-1), len+1);
	// Write ftab to primary file
	for(uint32_t i = 0; i < ftabLen; i++) {
		writeU32(out1, ftab[i], this->toBe());
	}
	// Write eftab to primary file
	for(uint32_t i = 0; i < eftabLen; i++) {
		writeU32(out1, eftab[i], this->toBe());
	}
	delete[] ftab;
	delete[] eftab;
	delete[] absorbFtab;

	// Note: if you'd like to sanity-check the Ebwt, you'll have to
	// read it back into memory first!
	assert(!isInMemory());
	VMSG_NL("Exiting Ebwt::buildToDisk()");
}

#endif /*EBWT_H_*/
